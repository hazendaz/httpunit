<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">httpunit</a> &gt; <a href="index.source.html" class="el_package">com.meterware.httpunit</a> &gt; <span class="el_source">WebClient.java</span></div><h1>WebClient.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright 2011-2025 Russell Gold
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
 * to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package com.meterware.httpunit;

import com.meterware.httpunit.cookies.Cookie;
import com.meterware.httpunit.cookies.CookieJar;

import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.PasswordAuthentication;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.xml.sax.SAXException;

/**
 * The context for a series of web requests. This class manages cookies used to maintain session context, computes
 * relative URLs, and generally emulates the browser behavior needed to build an automated test of a web site.
 **/
public abstract class WebClient {

    /** The open windows. */
<span class="fc" id="L49">    private ArrayList _openWindows = new ArrayList&lt;&gt;();</span>

    /** The current main window. **/
<span class="fc" id="L52">    private WebWindow _mainWindow = new WebWindow(this);</span>

    /** An authorization string to be sent with every request, whether challenged or not. May be null. **/
    private String _fixedAuthorizationString;

    /** An authorization string to be sent with the next request only. May be null. **/
    private String _authorizationString;

    /** The proxy authorization string. */
    private String _proxyAuthorizationString;

    /** The credentials. */
<span class="fc" id="L64">    private Hashtable _credentials = new Hashtable&lt;&gt;();</span>

    /**
     * Gets the main window.
     *
     * @return the main window
     */
    public WebWindow getMainWindow() {
<span class="fc" id="L72">        return _mainWindow;</span>
    }

    /**
     * Sets the main window.
     *
     * @param mainWindow
     *            the new main window
     */
    public void setMainWindow(WebWindow mainWindow) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (!_openWindows.contains(mainWindow)) {</span>
<span class="nc" id="L83">            throw new IllegalArgumentException(&quot;May only select an open window owned by this client&quot;);</span>
        }
<span class="nc" id="L85">        _mainWindow = mainWindow;</span>
<span class="nc" id="L86">    }</span>

    /**
     * Gets the open windows.
     *
     * @return the open windows
     */
    public WebWindow[] getOpenWindows() {
<span class="fc" id="L94">        return (WebWindow[]) _openWindows.toArray(new WebWindow[_openWindows.size()]);</span>
    }

    /**
     * Gets the open window.
     *
     * @param name
     *            the name
     *
     * @return the open window
     */
    public WebWindow getOpenWindow(String name) {
<span class="pc bpc" id="L106" title="2 of 4 branches missed.">        if (name == null || name.isEmpty()) {</span>
<span class="nc" id="L107">            return null;</span>
        }
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        for (Iterator i = _openWindows.iterator(); i.hasNext();) {</span>
<span class="fc" id="L110">            WebWindow window = (WebWindow) i.next();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (name.equals(window.getName())) {</span>
<span class="fc" id="L112">                return window;</span>
            }
<span class="fc" id="L114">        }</span>
<span class="nc" id="L115">        return null;</span>
    }

    /**
     * Submits a GET method request and returns a response.
     *
     * @param urlString
     *            the url string
     *
     * @return the response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the retrieved page
     */
    public WebResponse getResponse(String urlString) throws IOException, SAXException {
<span class="fc" id="L133">        return _mainWindow.getResponse(urlString);</span>
    }

    /**
     * Submits a web request and returns a response. This is an alternate name for the getResponse method.
     *
     * @param request
     *            the request
     *
     * @return the web response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     * @throws SAXException
     *             the SAX exception
     */
    public WebResponse sendRequest(WebRequest request) throws IOException, SAXException {
<span class="fc" id="L150">        return _mainWindow.sendRequest(request);</span>
    }

    /**
     * Returns the response representing the current top page in the main window.
     *
     * @return the current page
     */
    public WebResponse getCurrentPage() {
<span class="fc" id="L159">        return _mainWindow.getCurrentPage();</span>
    }

    /**
     * Submits a web request and returns a response, using all state developed so far as stored in cookies as requested
     * by the server.
     *
     * @param request
     *            the request
     *
     * @return the response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the retrieved page
     */
    public WebResponse getResponse(WebRequest request) throws IOException, SAXException {
<span class="fc" id="L178">        return _mainWindow.getResponse(request);</span>
    }

    /**
     * Returns the name of the currently active frames in the main window.
     *
     * @return the frame names
     */
    public String[] getFrameNames() {
<span class="fc" id="L187">        return _mainWindow.getFrameNames();</span>
    }

    /**
     * Returns the response associated with the specified frame name in the main window. Throws a runtime exception if
     * no matching frame is defined.
     *
     * @param frameName
     *            the frame name
     *
     * @return the frame contents
     */
    public WebResponse getFrameContents(String frameName) {
<span class="fc" id="L200">        return _mainWindow.getFrameContents(frameName);</span>
    }

    /**
     * Returns the response associated with the specified frame name in the main window. Throws a runtime exception if
     * no matching frame is defined.
     *
     * @param targetFrame
     *            the target frame
     *
     * @return the frame contents
     */
    public WebResponse getFrameContents(FrameSelector targetFrame) {
<span class="fc" id="L213">        return _mainWindow.getFrameContents(targetFrame);</span>
    }

    /**
     * Returns the resource specified by the request. Does not update the client or load included framesets or scripts.
     * May return null if the resource is a JavaScript URL which would normally leave the client unchanged.
     *
     * @param request
     *            the request
     *
     * @return the resource
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public WebResponse getResource(WebRequest request) throws IOException {
<span class="nc" id="L229">        return _mainWindow.getResource(request);</span>
    }

    /**
     * Resets the state of this client, removing all cookies, frames, and per-client headers. This does not affect any
     * listeners or preferences which may have been set.
     **/
    public void clearContents() {
<span class="nc" id="L237">        _mainWindow = new WebWindow(this);</span>
<span class="nc" id="L238">        _cookieJar.clear();</span>
<span class="nc" id="L239">        _headers = new HeaderDictionary();</span>
<span class="nc" id="L240">    }</span>

    /**
     * Defines a cookie to be sent to the server on every request.
     *
     * @param name
     *            the name
     * @param value
     *            the value
     *
     * @deprecated as of 1.6, use #putCookie instead.
     */
    @Deprecated
    public void addCookie(String name, String value) {
<span class="nc" id="L254">        _cookieJar.addCookie(name, value);</span>
<span class="nc" id="L255">    }</span>

    /**
     * Defines a cookie to be sent to the server on every request. This overrides any previous setting for this cookie
     * name.
     *
     * @param name
     *            the name
     * @param value
     *            the value
     */
    public void putCookie(String name, String value) {
<span class="fc" id="L267">        _cookieJar.putCookie(name, value);</span>
<span class="fc" id="L268">    }</span>

    /**
     * Returns the name of all the active cookies which will be sent to the server.
     *
     * @return the cookie names
     */
    public String[] getCookieNames() {
<span class="fc" id="L276">        return _cookieJar.getCookieNames();</span>
    }

    /**
     * Returns an object containing the details of the named cookie.
     *
     * @param name
     *            the name
     *
     * @return the cookie details
     */
    public Cookie getCookieDetails(String name) {
<span class="fc" id="L288">        return _cookieJar.getCookie(name);</span>
    }

    /**
     * Returns the value of the specified cookie.
     *
     * @param name
     *            the name
     *
     * @return the cookie value
     */
    public String getCookieValue(String name) {
<span class="fc" id="L300">        return _cookieJar.getCookieValue(name);</span>
    }

    /**
     * Returns the properties associated with this client.
     *
     * @return the client properties
     */
    public ClientProperties getClientProperties() {
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (_clientProperties == null) {</span>
<span class="fc" id="L310">            _clientProperties = ClientProperties.getDefaultProperties().cloneProperties();</span>
        }
<span class="fc" id="L312">        return _clientProperties;</span>
    }

    /**
     * Specifies the user agent identification. Used to trigger browser-specific server behavior.
     *
     * @param userAgent
     *            the new user agent
     *
     * @deprecated as of 1.4.6. Use ClientProperties#setUserAgent instead.
     */
    @Deprecated
    public void setUserAgent(String userAgent) {
<span class="nc" id="L325">        getClientProperties().setUserAgent(userAgent);</span>
<span class="nc" id="L326">    }</span>

    /**
     * Returns the current user agent setting.
     *
     * @return the user agent
     *
     * @deprecated as of 1.4.6. Use ClientProperties#getUserAgent instead.
     */
    @Deprecated
    public String getUserAgent() {
<span class="nc" id="L337">        return getClientProperties().getUserAgent();</span>
    }

    /**
     * Sets a username and password for a basic authentication scheme. Use #setAuthentication for more accurate
     * emulation of browser behavior.
     *
     * @param userName
     *            the user name
     * @param password
     *            the password
     */
    public void setAuthorization(String userName, String password) {
<span class="fc" id="L350">        _fixedAuthorizationString = &quot;Basic &quot;</span>
<span class="fc" id="L351">                + Base64.getEncoder().encodeToString((userName + ':' + password).getBytes(StandardCharsets.UTF_8));</span>
<span class="fc" id="L352">    }</span>

    /**
     * Specifies a username and password for on-demand authentication. Will only send the authorization header when
     * challenged for the specified realm.
     *
     * @param realm
     *            the realm for which the credentials apply.
     * @param username
     *            the user to authenticate
     * @param password
     *            the credentials for the user
     */
    public void setAuthentication(String realm, String username, String password) {
<span class="fc" id="L366">        _credentials.put(realm, new PasswordAuthentication(username, password.toCharArray()));</span>
<span class="fc" id="L367">    }</span>

    /**
     * get the credentials for the given realm.
     *
     * @param realm
     *            the realm
     *
     * @return the credentials for realm
     */
    PasswordAuthentication getCredentialsForRealm(String realm) {
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        if (_credentials == null) {</span>
<span class="nc" id="L379">            throw new Error(&quot;null _credentials while calling getCredentialsForRealm&quot;);</span>
        }
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (realm == null) {</span>
<span class="nc" id="L382">            throw new Error(&quot;null realm while calling getCredentialsForRealm&quot;);</span>
        }
<span class="fc" id="L384">        return (PasswordAuthentication) _credentials.get(realm);</span>
    }

    /**
     * Specifies a proxy server to use for requests from this client.
     *
     * @param proxyHost
     *            the proxy host
     * @param proxyPort
     *            the proxy port
     */
    public abstract void setProxyServer(String proxyHost, int proxyPort);

    /**
     * Specifies a proxy server to use, along with a user and password for authentication.
     *
     * @param proxyHost
     *            the proxy host
     * @param proxyPort
     *            the proxy port
     * @param userName
     *            the user name
     * @param password
     *            the password
     */
    public void setProxyServer(String proxyHost, int proxyPort, String userName, String password) {
<span class="nc" id="L410">        setProxyServer(proxyHost, proxyPort);</span>
<span class="nc" id="L411">        _proxyAuthorizationString = &quot;Basic &quot;</span>
<span class="nc" id="L412">                + Base64.getEncoder().encodeToString((userName + ':' + password).getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L413">    }</span>

    /**
     * Clears the proxy server settings.
     */
    public void clearProxyServer() {
<span class="nc" id="L419">    }</span>

    /**
     * Returns the name of the active proxy server.
     *
     * @return the proxy host
     */
    public String getProxyHost() {
<span class="nc" id="L427">        return System.getProperty(&quot;proxyHost&quot;);</span>
    }

    /**
     * Returns the number of the active proxy port, or 0 is none is specified.
     *
     * @return the proxy port
     */
    public int getProxyPort() {
        try {
<span class="nc" id="L437">            return Integer.getInteger(&quot;proxyPort&quot;);</span>
<span class="nc" id="L438">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L439">            return 0;</span>
        }
    }

    /**
     * Sets the value for a header field to be sent with all requests. If the value set is null, removes the header from
     * those to be sent.
     *
     * @param fieldName
     *            the field name
     * @param fieldValue
     *            the field value
     */
    public void setHeaderField(String fieldName, String fieldValue) {
<span class="fc" id="L453">        _headers.put(fieldName, fieldValue);</span>
<span class="fc" id="L454">    }</span>

    /**
     * Returns the value for the header field with the specified name. This method will ignore the case of the field
     * name.
     *
     * @param fieldName
     *            the field name
     *
     * @return the header field
     */
    public String getHeaderField(String fieldName) {
<span class="nc" id="L466">        return (String) _headers.get(fieldName);</span>
    }

    /**
     * Specifies whether an exception will be thrown when an error status (4xx or 5xx) is detected on a response.
     * Defaults to the value returned by HttpUnitOptions.getExceptionsThrownOnErrorStatus.
     *
     * @param throwExceptions
     *            the new exceptions thrown on error status
     */
    public void setExceptionsThrownOnErrorStatus(boolean throwExceptions) {
<span class="fc" id="L477">        _exceptionsThrownOnErrorStatus = throwExceptions;</span>
<span class="fc" id="L478">    }</span>

    /**
     * Returns true if an exception will be thrown when an error status (4xx or 5xx) is detected on a response.
     *
     * @return the exceptions thrown on error status
     */
    public boolean getExceptionsThrownOnErrorStatus() {
<span class="fc" id="L486">        return _exceptionsThrownOnErrorStatus;</span>
    }

    /**
     * Adds a listener to watch for requests and responses.
     *
     * @param listener
     *            the listener
     */
    public void addClientListener(WebClientListener listener) {
<span class="fc" id="L496">        synchronized (_clientListeners) {</span>
<span class="pc bpc" id="L497" title="2 of 4 branches missed.">            if (listener != null &amp;&amp; !_clientListeners.contains(listener)) {</span>
<span class="fc" id="L498">                _clientListeners.add(listener);</span>
            }
<span class="fc" id="L500">        }</span>
<span class="fc" id="L501">    }</span>

    /**
     * Removes a listener to watch for requests and responses.
     *
     * @param listener
     *            the listener
     */
    public void removeClientListener(WebClientListener listener) {
<span class="nc" id="L510">        synchronized (_clientListeners) {</span>
<span class="nc" id="L511">            _clientListeners.remove(listener);</span>
<span class="nc" id="L512">        }</span>
<span class="nc" id="L513">    }</span>

    /**
     * Adds a listener to watch for window openings and closings.
     *
     * @param listener
     *            the listener
     */
    public void addWindowListener(WebWindowListener listener) {
<span class="fc" id="L522">        synchronized (_windowListeners) {</span>
<span class="pc bpc" id="L523" title="2 of 4 branches missed.">            if (listener != null &amp;&amp; !_windowListeners.contains(listener)) {</span>
<span class="fc" id="L524">                _windowListeners.add(listener);</span>
            }
<span class="fc" id="L526">        }</span>
<span class="fc" id="L527">    }</span>

    /**
     * Removes a listener to watch for window openings and closings.
     *
     * @param listener
     *            the listener
     */
    public void removeWindowListener(WebWindowListener listener) {
<span class="nc" id="L536">        synchronized (_windowListeners) {</span>
<span class="nc" id="L537">            _windowListeners.remove(listener);</span>
<span class="nc" id="L538">        }</span>
<span class="nc" id="L539">    }</span>

    /**
     * Returns the next javascript alert without removing it from the queue.
     *
     * @return the next alert
     */
    public String getNextAlert() {
<span class="fc bfc" id="L547" title="All 2 branches covered.">        return _alerts.isEmpty() ? null : (String) _alerts.getFirst();</span>
    }

    /**
     * Returns the next javascript alert and removes it from the queue. If the queue is empty, will return an empty
     * string.
     *
     * @return the string
     */
    public String popNextAlert() {
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if (_alerts.isEmpty()) {</span>
<span class="fc" id="L558">            return &quot;&quot;;</span>
        }
<span class="fc" id="L560">        return (String) _alerts.removeFirst();</span>
    }

    /**
     * Specifies the object which will respond to all dialogs.
     *
     * @param responder
     *            the new dialog responder
     */
    public void setDialogResponder(DialogResponder responder) {
<span class="fc" id="L570">        _dialogResponder = responder;</span>
<span class="fc" id="L571">    }</span>

    // ------------------------------------------ protected members -----------------------------------

    /**
     * Instantiates a new web client.
     */
<span class="fc" id="L578">    protected WebClient() {</span>
<span class="fc" id="L579">        _openWindows.add(_mainWindow);</span>
<span class="fc" id="L580">    }</span>

    /**
     * Creates a web response object which represents the response to the specified web request.
     *
     * @param request
     *            the request to which the response should be generated
     * @param targetFrame
     *            the frame in which the response should be stored
     *
     * @return the web response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    abstract protected WebResponse newResponse(WebRequest request, FrameSelector targetFrame) throws IOException;

    /**
     * Writes the message body for the request.
     *
     * @param request
     *            the request
     * @param stream
     *            the stream
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    protected final void writeMessageBody(WebRequest request, OutputStream stream) throws IOException {
<span class="fc" id="L609">        request.writeMessageBody(stream);</span>
<span class="fc" id="L610">    }</span>

    /**
     * Returns the value of all current header fields.
     *
     * @param targetURL
     *            the target URL
     *
     * @return the header fields
     */
    protected Dictionary getHeaderFields(URL targetURL) {
<span class="fc" id="L621">        Hashtable result = (Hashtable) _headers.clone();</span>
<span class="fc" id="L622">        result.put(&quot;User-Agent&quot;, getClientProperties().getUserAgent());</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (getClientProperties().isAcceptGzip()) {</span>
<span class="fc" id="L624">            result.put(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span>
        }
<span class="fc" id="L626">        AddHeaderIfNotNull(result, &quot;Cookie&quot;, _cookieJar.getCookieHeaderField(targetURL));</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (_authorizationString == null) {</span>
<span class="fc" id="L628">            _authorizationString = _fixedAuthorizationString;</span>
        }
<span class="fc" id="L630">        AddHeaderIfNotNull(result, &quot;Authorization&quot;, _authorizationString);</span>
<span class="fc" id="L631">        AddHeaderIfNotNull(result, &quot;Proxy-Authorization&quot;, _proxyAuthorizationString);</span>
<span class="fc" id="L632">        _authorizationString = null;</span>
<span class="fc" id="L633">        return result;</span>
    }

    /**
     * Adds the header if not null.
     *
     * @param result
     *            the result
     * @param headerName
     *            the header name
     * @param headerValue
     *            the header value
     */
    private void AddHeaderIfNotNull(Hashtable result, final String headerName, final String headerValue) {
<span class="fc bfc" id="L647" title="All 2 branches covered.">        if (headerValue != null) {</span>
<span class="fc" id="L648">            result.put(headerName, headerValue);</span>
        }
<span class="fc" id="L650">    }</span>

    /**
     * Updates this web client based on a received response. This includes updating cookies and frames. This method is
     * required by ServletUnit, which cannot call the updateWindow method directly.
     *
     * @param frame
     *            the frame
     * @param response
     *            the response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     * @throws SAXException
     *             the SAX exception
     */
    protected final void updateMainWindow(FrameSelector frame, WebResponse response) throws IOException, SAXException {
<span class="fc" id="L667">        getMainWindow().updateWindow(frame.getName(), response, new RequestContext());</span>
<span class="fc" id="L668">    }</span>

    // ------------------------------------------------- package members
    // ----------------------------------------------------

    /**
     * Tell listeners.
     *
     * @param request
     *            the request
     */
    void tellListeners(WebRequest request) {
        List listeners;

<span class="fc" id="L682">        synchronized (_clientListeners) {</span>
<span class="fc" id="L683">            listeners = new ArrayList(_clientListeners);</span>
<span class="fc" id="L684">        }</span>

<span class="fc bfc" id="L686" title="All 2 branches covered.">        for (Iterator i = listeners.iterator(); i.hasNext();) {</span>
<span class="fc" id="L687">            ((WebClientListener) i.next()).requestSent(this, request);</span>
        }
<span class="fc" id="L689">    }</span>

    /**
     * Tell listeners.
     *
     * @param response
     *            the response
     */
    void tellListeners(WebResponse response) {
        List listeners;

<span class="fc" id="L700">        synchronized (_clientListeners) {</span>
<span class="fc" id="L701">            listeners = new ArrayList(_clientListeners);</span>
<span class="fc" id="L702">        }</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">        for (Iterator i = listeners.iterator(); i.hasNext();) {</span>
<span class="fc" id="L705">            ((WebClientListener) i.next()).responseReceived(this, response);</span>
        }
<span class="fc" id="L707">    }</span>

    /**
     * Update client.
     *
     * @param response
     *            the response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    void updateClient(WebResponse response) throws IOException {
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (getClientProperties().isAcceptCookies()) {</span>
<span class="fc" id="L720">            _cookieJar.updateCookies(response.getCookieJar());</span>
        }
<span class="fc" id="L722">        validateHeaders(response);</span>
<span class="fc" id="L723">    }</span>

    /**
     * Support Request [ 1288796 ] getCookieJar() in WebClient.
     *
     * @return the cookie jar
     *
     * @deprecated - use with care - was not public in the past
     */
    @Deprecated
    public CookieJar getCookieJar() {
<span class="fc" id="L734">        return _cookieJar;</span>
    }

    /**
     * Update frame contents.
     *
     * @param requestWindow
     *            the request window
     * @param requestTarget
     *            the request target
     * @param response
     *            the response
     * @param requestContext
     *            the request context
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     * @throws SAXException
     *             the SAX exception
     */
    void updateFrameContents(WebWindow requestWindow, String requestTarget, WebResponse response,
            RequestContext requestContext) throws IOException, SAXException {
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (response.getFrame() == FrameSelector.NEW_FRAME) {</span>
<span class="fc" id="L757">            WebWindow window = new WebWindow(this, requestWindow.getCurrentPage());</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (!WebRequest.NEW_WINDOW.equalsIgnoreCase(requestTarget)) {</span>
<span class="fc" id="L759">                window.setName(requestTarget);</span>
            }
<span class="fc" id="L761">            response.setFrame(window.getTopFrame());</span>
<span class="fc" id="L762">            window.updateFrameContents(response, requestContext);</span>
<span class="fc" id="L763">            _openWindows.add(window);</span>
<span class="fc" id="L764">            reportWindowOpened(window);</span>
<span class="fc bfc" id="L765" title="All 4 branches covered.">        } else if (response.getFrame().getWindow() != null &amp;&amp; response.getFrame().getWindow() != requestWindow) {</span>
<span class="fc" id="L766">            response.getFrame().getWindow().updateFrameContents(response, requestContext);</span>
        } else {
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (response.getFrame() == FrameSelector.TOP_FRAME) {</span>
<span class="fc" id="L769">                response.setFrame(requestWindow.getTopFrame());</span>
            }
<span class="fc" id="L771">            requestWindow.updateFrameContents(response, requestContext);</span>
        }
<span class="fc" id="L773">    }</span>

    /**
     * Close.
     *
     * @param window
     *            the window
     */
    void close(WebWindow window) {
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        if (!_openWindows.contains(window)) {</span>
<span class="nc" id="L783">            throw new IllegalStateException(&quot;Window is already closed&quot;);</span>
        }
<span class="fc" id="L785">        _openWindows.remove(window);</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (_openWindows.isEmpty()) {</span>
<span class="fc" id="L787">            _openWindows.add(new WebWindow(this));</span>
        }
<span class="fc bfc" id="L789" title="All 2 branches covered.">        if (window.equals(_mainWindow)) {</span>
<span class="fc" id="L790">            _mainWindow = (WebWindow) _openWindows.get(0);</span>
        }
<span class="fc" id="L792">        reportWindowClosed(window);</span>
<span class="fc" id="L793">    }</span>

    /**
     * Report window opened.
     *
     * @param window
     *            the window
     */
    private void reportWindowOpened(WebWindow window) {
        List listeners;

<span class="fc" id="L804">        synchronized (_windowListeners) {</span>
<span class="fc" id="L805">            listeners = new ArrayList(_windowListeners);</span>
<span class="fc" id="L806">        }</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">        for (Iterator i = listeners.iterator(); i.hasNext();) {</span>
<span class="fc" id="L809">            ((WebWindowListener) i.next()).windowOpened(this, window);</span>
        }
<span class="fc" id="L811">    }</span>

    /**
     * Report window closed.
     *
     * @param window
     *            the window
     */
    private void reportWindowClosed(WebWindow window) {
        List listeners;

<span class="fc" id="L822">        synchronized (_windowListeners) {</span>
<span class="fc" id="L823">            listeners = new ArrayList(_windowListeners);</span>
<span class="fc" id="L824">        }</span>

<span class="fc bfc" id="L826" title="All 2 branches covered.">        for (Iterator i = listeners.iterator(); i.hasNext();) {</span>
<span class="fc" id="L827">            ((WebWindowListener) i.next()).windowClosed(this, window);</span>
        }
<span class="fc" id="L829">    }</span>

    // ------------------------------------------ package members ------------------------------------

    /**
     * Gets the confirmation response.
     *
     * @param message
     *            the message
     *
     * @return the confirmation response
     */
    boolean getConfirmationResponse(String message) {
<span class="fc" id="L842">        return _dialogResponder.getConfirmation(message);</span>
    }

    /**
     * Gets the user response.
     *
     * @param message
     *            the message
     * @param defaultResponse
     *            the default response
     *
     * @return the user response
     */
    String getUserResponse(String message, String defaultResponse) {
<span class="fc" id="L856">        return _dialogResponder.getUserResponse(message, defaultResponse);</span>
    }

    /**
     * simulate an alert by remembering the alert message on a Stack.
     *
     * @param message
     *            - the alert message to post
     */
    void postAlert(String message) {
<span class="fc" id="L866">        _alerts.addLast(message);</span>
<span class="fc" id="L867">    }</span>

    // ------------------------------------------ private members -------------------------------------

    /** The list of alerts generated by JavaScript. **/
<span class="fc" id="L872">    private LinkedList _alerts = new LinkedList();</span>

    /** The currently defined cookies. **/
<span class="fc" id="L875">    private CookieJar _cookieJar = new CookieJar();</span>

    /** A map of header names to values. **/
<span class="fc" id="L878">    private HeaderDictionary _headers = new HeaderDictionary();</span>

    /** The exceptions thrown on error status. */
<span class="fc" id="L881">    private boolean _exceptionsThrownOnErrorStatus = HttpUnitOptions.getExceptionsThrownOnErrorStatus();</span>

    /** The client listeners. */
<span class="fc" id="L884">    private final List _clientListeners = new ArrayList&lt;&gt;();</span>

    /** The window listeners. */
<span class="fc" id="L887">    private final List _windowListeners = new ArrayList&lt;&gt;();</span>

    /** The dialog responder. */
<span class="fc" id="L890">    private DialogResponder _dialogResponder = new DialogAdapter();</span>

    /** The client properties. */
    private ClientProperties _clientProperties;

    /**
     * Examines the headers in the response and throws an exception if appropriate.
     *
     * @param response
     *            the response
     *
     * @throws HttpException
     *             the http exception
     *
     * @parm response - the response to validate
     */
    private void validateHeaders(WebResponse response) throws HttpException {
<span class="fc" id="L907">        HttpException exception = null;</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">        if (response.getResponseCode() == HttpURLConnection.HTTP_INTERNAL_ERROR) {</span>
<span class="nc" id="L909">            exception = new HttpInternalErrorException(response.getURL());</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">        } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {</span>
<span class="fc" id="L911">            exception = new HttpNotFoundException(response.getResponseMessage(), response.getURL());</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">        } else if (response.getResponseCode() &gt;= HttpURLConnection.HTTP_BAD_REQUEST) {</span>
<span class="fc" id="L913">            exception = new HttpException(response.getResponseCode(), response.getResponseMessage(), response.getURL());</span>
        }
        // is there an exception?
<span class="fc bfc" id="L916" title="All 2 branches covered.">        if (exception != null) {</span>
            // see feature request [ 914314 ] Add HttpException.getResponse for better reporting
<span class="fc" id="L918">            exception.setResponse(response);</span>
            // shall we ignore errors?
<span class="fc bfc" id="L920" title="All 2 branches covered.">            if (!getExceptionsThrownOnErrorStatus()) {</span>
<span class="fc" id="L921">                return;</span>
            }
<span class="fc" id="L923">            throw exception;</span>
        }
<span class="fc" id="L925">    }</span>

    /**
     * Find frame.
     *
     * @param target
     *            the target
     *
     * @return the frame selector
     */
    FrameSelector findFrame(String target) {
<span class="fc bfc" id="L936" title="All 2 branches covered.">        for (Object _openWindow : _openWindows) {</span>
<span class="fc" id="L937">            WebWindow webWindow = (WebWindow) _openWindow;</span>
<span class="fc" id="L938">            FrameSelector frame = webWindow.getFrame(target);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">            if (frame != null) {</span>
<span class="fc" id="L940">                return frame;</span>
            }
<span class="fc" id="L942">        }</span>
<span class="fc" id="L943">        return null;</span>
    }

    /**
     * Sends a request and returns a response after dealing with any authentication challenge. If challenged and able to
     * respond, resends the request after setting the authentication header (which will apply only for the that
     * request).
     *
     * @param request
     *            the original request
     * @param targetFrame
     *            the frame into which the result will be stored
     *
     * @return a response from the server
     *
     * @throws IOException
     *             if an exception (including authorization failure) occurs
     */
    WebResponse createResponse(WebRequest request, FrameSelector targetFrame) throws IOException {
<span class="fc" id="L962">        WebResponse response = newResponse(request, targetFrame);</span>
<span class="fc" id="L963">        AuthenticationChallenge challenge = new AuthenticationChallenge(this, request,</span>
<span class="fc" id="L964">                response.getHeaderField(&quot;WWW-Authenticate&quot;));</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">        if (!challenge.needToAuthenticate()) {</span>
<span class="fc" id="L966">            return response;</span>
        }
<span class="fc" id="L968">        setOnetimeAuthenticationHeader(challenge.createAuthenticationHeader());</span>
<span class="fc" id="L969">        WebResponse response2 = newResponse(request, targetFrame);</span>
<span class="pc bpc" id="L970" title="3 of 4 branches missed.">        if (response2.getHeaderField(&quot;WWW-Authenticate&quot;) != null &amp;&amp; getExceptionsThrownOnErrorStatus()) {</span>
<span class="nc" id="L971">            throw AuthenticationChallenge.createException(response2.getHeaderField(&quot;WWW-Authenticate&quot;));</span>
        }
<span class="fc" id="L973">        return response2;</span>
    }

    /**
     * Sets the onetime authentication header.
     *
     * @param authorizationHeader
     *            the new onetime authentication header
     */
    private void setOnetimeAuthenticationHeader(String authorizationHeader) {
<span class="fc" id="L983">        _authorizationString = authorizationHeader;</span>
<span class="fc" id="L984">    }</span>

    // ==================================================================================================

    /**
     * The Class HeaderDictionary.
     */
<span class="fc" id="L991">    static public class HeaderDictionary extends Hashtable {</span>

        /** The Constant serialVersionUID. */
        private static final long serialVersionUID = 1L;

        /**
         * Adds the entries.
         *
         * @param source
         *            the source
         */
        public void addEntries(Dictionary source) {
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            for (Enumeration e = source.keys(); e.hasMoreElements();) {</span>
<span class="fc" id="L1004">                Object key = e.nextElement();</span>
<span class="fc" id="L1005">                put(key, source.get(key));</span>
<span class="fc" id="L1006">            }</span>
<span class="fc" id="L1007">        }</span>

        @Override
        public boolean containsKey(Object key) {
<span class="fc" id="L1011">            return super.containsKey(matchPreviousFieldName(key.toString()));</span>
        }

        @Override
        public Object get(Object fieldName) {
<span class="fc" id="L1016">            return super.get(matchPreviousFieldName(fieldName.toString()));</span>
        }

        @Override
        public Object put(Object fieldName, Object fieldValue) {
<span class="fc" id="L1021">            fieldName = matchPreviousFieldName(fieldName.toString());</span>
<span class="fc" id="L1022">            Object oldValue = super.get(fieldName);</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">            if (fieldValue == null) {</span>
<span class="nc" id="L1024">                remove(fieldName);</span>
            } else {
<span class="fc" id="L1026">                super.put(fieldName, fieldValue);</span>
            }
<span class="fc" id="L1028">            return oldValue;</span>
        }

        /**
         * If a matching field name with different case is already known, returns the older name. Otherwise, returns the
         * specified name.
         *
         * @param fieldName
         *            the field name
         *
         * @return the string
         */
        private String matchPreviousFieldName(String fieldName) {
<span class="fc bfc" id="L1041" title="All 2 branches covered.">            for (Enumeration e = keys(); e.hasMoreElements();) {</span>
<span class="fc" id="L1042">                String key = (String) e.nextElement();</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">                if (key.equalsIgnoreCase(fieldName)) {</span>
<span class="fc" id="L1044">                    return key;</span>
                }
<span class="fc" id="L1046">            }</span>
<span class="fc" id="L1047">            return fieldName;</span>
        }

    }

}

// ==================================================================================================

class RedirectWebRequest extends WebRequest {

    RedirectWebRequest(WebResponse response) {
<span class="fc" id="L1059">        super(response.getURL(), response.getHeaderField(&quot;Location&quot;), response.getFrame(), response.getFrameName());</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">        if (response.getReferer() != null) {</span>
<span class="fc" id="L1061">            setHeaderField(&quot;Referer&quot;, response.getReferer());</span>
        }
<span class="fc" id="L1063">    }</span>

    /**
     * Returns the HTTP method defined for this request.
     **/
    @Override
    public String getMethod() {
<span class="fc" id="L1070">        return &quot;GET&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>