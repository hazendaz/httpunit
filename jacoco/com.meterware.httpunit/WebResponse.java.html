<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebResponse.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">httpunit</a> &gt; <a href="index.source.html" class="el_package">com.meterware.httpunit</a> &gt; <span class="el_source">WebResponse.java</span></div><h1>WebResponse.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright 2011-2025 Russell Gold
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
 * to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
package com.meterware.httpunit;

import com.meterware.httpunit.cookies.CookieJar;
import com.meterware.httpunit.cookies.CookieSource;
import com.meterware.httpunit.dom.DomWindow;
import com.meterware.httpunit.dom.DomWindowProxy;
import com.meterware.httpunit.dom.HTMLDocumentImpl;
import com.meterware.httpunit.dom.HTMLElementImpl;
import com.meterware.httpunit.protocol.MessageBody;
import com.meterware.httpunit.scripting.NamedDelegate;
import com.meterware.httpunit.scripting.ScriptableDelegate;
import com.meterware.httpunit.scripting.ScriptingHandler;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.charset.UnsupportedCharsetException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Locale;
import java.util.zip.GZIPInputStream;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * A response to a web request from a web server.
 **/
public abstract class WebResponse implements HTMLSegment, CookieSource, DomWindowProxy {

    /** The Constant HTML_CONTENT. */
    private static final String HTML_CONTENT = &quot;text/html&quot;;

    /** The Constant XHTML_CONTENT. */
    private static final String XHTML_CONTENT = &quot;application/xhtml+xml&quot;;

    /** The Constant FAUX_XHTML_CONTENT. */
    private static final String FAUX_XHTML_CONTENT = &quot;text/xhtml&quot;;
    // [ 1281655 ] [patch] allow text/xml to be parsed as html
    /** The Constant XML_CONTENT. */
    // testTraversal test changed after positive reply by Russell
    private static final String XML_CONTENT = &quot;text/xml&quot;;

    /** The valid content types. */
    // the list of valid content Types
<span class="fc" id="L77">    private static String[] validContentTypes = { HTML_CONTENT, XHTML_CONTENT, FAUX_XHTML_CONTENT, XML_CONTENT };</span>

    /** The Constant UNINITIALIZED_INT. */
    private static final int UNINITIALIZED_INT = -2;

    /** The Constant UNKNOWN_LENGTH_TIMEOUT. */
    private static final int UNKNOWN_LENGTH_TIMEOUT = 500;

    /** The Constant UNKNOWN_LENGTH_RETRY_INTERVAL. */
    private static final int UNKNOWN_LENGTH_RETRY_INTERVAL = 10;

    /** The frame. */
    private FrameSelector _frame;

    /** The with parse. */
    // allow to switch off parsing e.g. for method=&quot;HEAD&quot;
<span class="fc" id="L93">    private boolean _withParse = true;</span>

    /** The base target. */
    private String _baseTarget;

    /** The refresh header. */
    private String _refreshHeader;

    /** The base URL. */
    private URL _baseURL;

    /** The parsing page. */
    private boolean _parsingPage;

    /**
     * is parsing on?.
     *
     * @return true if parsing is enabled
     */
    public boolean isWithParse() {
<span class="fc" id="L113">        return _withParse;</span>
    }

    /**
     * set the parsing switch.
     *
     * @param doParse
     *            the new with parse
     */
    public void setWithParse(boolean doParse) {
<span class="fc" id="L123">        _withParse = doParse;</span>
<span class="fc" id="L124">    }</span>

    /**
     * Returns a web response built from a URL connection. Provided to allow access to WebResponse parsing without using
     * a WebClient.
     *
     * @param connection
     *            the connection
     *
     * @return the web response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public static WebResponse newResponse(URLConnection connection) throws IOException {
<span class="nc" id="L139">        return new HttpWebResponse(null, FrameSelector.TOP_FRAME, connection.getURL(), connection,</span>
<span class="nc" id="L140">                HttpUnitOptions.getExceptionsThrownOnErrorStatus());</span>
    }

    /**
     * Returns true if the response is HTML.
     *
     * @return true if the contenType fits
     **/
    public boolean isHTML() {
<span class="fc" id="L149">        boolean result = false;</span>
        // check the different content types
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (String validContentType : validContentTypes) {</span>
<span class="fc" id="L152">            result = getContentType().equalsIgnoreCase(validContentType);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            if (result) {</span>
<span class="fc" id="L154">                break;</span>
            }
        } // for
<span class="fc" id="L157">        return result;</span>
    }

    /**
     * Returns the URL which invoked this response.
     **/
    @Override
    public URL getURL() {
<span class="fc" id="L165">        return _pageURL;</span>
    }

    /**
     * Returns the title of the page.
     *
     * @return the title
     *
     * @exception SAXException
     *                thrown if there is an error parsing this response
     */
    public String getTitle() throws SAXException {
<span class="fc" id="L177">        return getReceivedPage().getTitle();</span>
    }

    /**
     * Returns the stylesheet linked in the head of the page. &amp;lt;code&amp;gt; &amp;lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot;
     * href=&quot;/mystyle.css&quot; /&amp;gt; &amp;lt;/code&amp;gt; will return &quot;/mystyle.css&quot;.
     *
     * @return the external style sheet
     *
     * @exception SAXException
     *                thrown if there is an error parsing this response
     */
    public String getExternalStyleSheet() throws SAXException {
<span class="fc" id="L190">        return getReceivedPage().getExternalStyleSheet();</span>
    }

    /**
     * Retrieves the &quot;content&quot; of the meta tags for a key pair attribute-attributeValue. &amp;lt;code&amp;gt; &amp;lt;meta
     * name=&quot;robots&quot; content=&quot;index&quot; /&amp;gt; &amp;lt;meta name=&quot;robots&quot; content=&quot;follow&quot; /&amp;gt; &amp;lt;meta http-equiv=&quot;Expires&quot;
     * content=&quot;now&quot; /&amp;gt; &amp;lt;/code&amp;gt; this can be used like this &amp;lt;code&amp;gt; getMetaTagContent(&quot;name&quot;,&quot;robots&quot;) will
     * return { &quot;index&quot;,&quot;follow&quot; } getMetaTagContent(&quot;http-equiv&quot;,&quot;Expires&quot;) will return { &quot;now&quot; } &amp;lt;/code&amp;gt;
     *
     * @param attribute
     *            the attribute
     * @param attributeValue
     *            the attribute value
     *
     * @return the meta tag content
     *
     * @exception SAXException
     *                thrown if there is an error parsing this response
     */
    public String[] getMetaTagContent(String attribute, String attributeValue) throws SAXException {
<span class="fc" id="L210">        return getReceivedPage().getMetaTagContent(attribute, attributeValue);</span>
    }

    /**
     * Returns the name of the frame containing this page.
     *
     * @return the frame name
     */
    public String getFrameName() {
<span class="fc" id="L219">        return _frame.getName();</span>
    }

    /**
     * Sets the frame.
     *
     * @param frame
     *            the new frame
     */
    void setFrame(FrameSelector frame) {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (!_frame.getName().equals(frame.getName())) {</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;May not modify the frame name&quot;);</span>
        }
<span class="fc" id="L232">        _frame = frame;</span>
<span class="fc" id="L233">    }</span>

    /**
     * Returns the frame containing this page.
     *
     * @return the frame
     */
    FrameSelector getFrame() {
<span class="fc" id="L241">        return _frame;</span>
    }

    /**
     * Returns a request to refresh this page, if any. This request will be defined by a meta tag in the header. If no
     * tag exists, will return null.
     *
     * @return the refresh request
     */
    public WebRequest getRefreshRequest() {
<span class="fc" id="L251">        readRefreshRequest();</span>
<span class="fc" id="L252">        return _refreshRequest;</span>
    }

    /**
     * Returns the delay before normally following the request to refresh this page, if any. This request will be
     * defined by a meta tag in the header. If no tag exists, will return zero.
     *
     * @return the refresh delay
     */
    public int getRefreshDelay() {
<span class="fc" id="L262">        readRefreshRequest();</span>
<span class="fc" id="L263">        return _refreshDelay;</span>
    }

    /**
     * Returns the response code associated with this response.
     *
     * @return the response code
     */
    public abstract int getResponseCode();

    /**
     * Returns the response message associated with this response.
     *
     * @return the response message
     */
    public abstract String getResponseMessage();

    /**
     * Returns the content length of this response.
     *
     * @return the content length, if known, or -1.
     */
    public int getContentLength() {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (_contentLength == UNINITIALIZED_INT) {</span>
<span class="fc" id="L287">            String length = getHeaderField(&quot;Content-Length&quot;);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            _contentLength = length == null ? -1 : Integer.parseInt(length);</span>
        }
<span class="fc" id="L290">        return _contentLength;</span>
    }

    /**
     * Returns the content type of this response.
     *
     * @return the content type
     */
    public String getContentType() {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (_contentType == null) {</span>
<span class="fc" id="L300">            readContentTypeHeader();</span>
        }
<span class="fc" id="L302">        return _contentType;</span>
    }

    /**
     * Returns the character set used in this response.
     *
     * @return the character set
     */
    public String getCharacterSet() {
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (_characterSet == null) {</span>
<span class="fc" id="L312">            readContentTypeHeader();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (_characterSet == null) {</span>
<span class="fc" id="L314">                setCharacterSet(getHeaderField(&quot;Charset&quot;));</span>
            }
<span class="fc bfc" id="L316" title="All 2 branches covered.">            if (_characterSet == null) {</span>
<span class="fc" id="L317">                setCharacterSet(HttpUnitOptions.getDefaultCharacterSet());</span>
            }
        }
<span class="fc" id="L320">        return _characterSet;</span>
    }

    /**
     * Returns a list of new cookie names defined as part of this response.
     *
     * @return the new cookie names
     */
    public String[] getNewCookieNames() {
<span class="fc" id="L329">        return getCookieJar().getCookieNames();</span>
    }

    /**
     * Returns the new cookie value defined as part of this response.
     *
     * @param name
     *            the name
     *
     * @return the new cookie value
     */
    public String getNewCookieValue(String name) {
<span class="nc" id="L341">        return getCookieJar().getCookieValue(name);</span>
    }

    /**
     * Returns the names of the header fields found in the response.
     *
     * @return the header field names
     */
    public abstract String[] getHeaderFieldNames();

    /**
     * Returns the value for the specified header field. If no such field is defined, will return null. If more than one
     * header is defined for the specified name, returns only the first found.
     *
     * @param fieldName
     *            the field name
     *
     * @return the header field
     */
    public abstract String getHeaderField(String fieldName);

    /**
     * Returns the actual byte stream of the response e.g. for download results
     *
     * @return the byte array read for this response
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public byte[] getBytes() throws IOException {
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (_responseText == null) {</span>
<span class="fc" id="L372">            loadResponseText();</span>
        }
<span class="fc" id="L374">        return _bytes;</span>
    }

    /**
     * Returns the text of the response (excluding headers) as a string. Use this method in preference to 'toString'
     * which may be used to represent internal state of this object.
     *
     * @return the response text
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public String getText() throws IOException {
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (_responseText == null) {</span>
<span class="fc" id="L388">            loadResponseText();</span>
        }
<span class="fc" id="L390">        return _responseText;</span>
    }

    /**
     * Returns a buffered input stream for reading the contents of this reply.
     *
     * @return the input stream
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public InputStream getInputStream() throws IOException {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (_inputStream == null) {</span>
<span class="fc" id="L403">            _inputStream = new ByteArrayInputStream(getText().getBytes(StandardCharsets.UTF_8));</span>
        }
<span class="fc" id="L405">        return _inputStream;</span>
    }

    /**
     * Returns the names of the frames found in the page in the order in which they appear.
     *
     * @return the frame names
     *
     * @exception SAXException
     *                thrown if there is an error parsing this response
     */
    public String[] getFrameNames() throws SAXException {
<span class="fc" id="L417">        WebFrame[] frames = getFrames();</span>
<span class="fc" id="L418">        String[] result = new String[frames.length];</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L420">            result[i] = frames[i].getFrameName();</span>
        }

<span class="fc" id="L423">        return result;</span>
    }

    /**
     * Returns the frames found in the page in the order in which they appear.
     *
     * @return the frame selectors
     *
     * @exception SAXException
     *                thrown if there is an error parsing this response
     */
    FrameSelector[] getFrameSelectors() throws SAXException {
<span class="fc" id="L435">        WebFrame[] frames = getFrames();</span>
<span class="fc" id="L436">        FrameSelector[] result = new FrameSelector[frames.length];</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L438">            result[i] = frames[i].getSelector();</span>
        }

<span class="fc" id="L441">        return result;</span>
    }

    /**
     * Returns the contents of the specified subframe of this frameset response.
     *
     * @param subFrameName
     *            the name of the desired frame as defined in the frameset.
     *
     * @return the subframe contents
     */
    public WebResponse getSubframeContents(String subFrameName) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (_window == null) {</span>
<span class="fc" id="L454">            throw new NoSuchFrameException(subFrameName);</span>
        }
<span class="fc" id="L456">        return _window.getSubframeContents(_frame, subFrameName);</span>
    }

    // ---------------------- HTMLSegment methods -----------------------------

    /**
     * Returns the HTMLElement with the specified ID.
     *
     * @throws SAXException
     *             thrown if there is an error parsing the response.
     */
    @Override
    public HTMLElement getElementWithID(String id) throws SAXException {
<span class="fc" id="L469">        return getReceivedPage().getElementWithID(id);</span>
    }

    /**
     * return the HTMLElements with the specified tag name.
     *
     * @param tagName
     *            e.g. &quot;div&quot; or &quot;table&quot;
     *
     * @return a list of all HTMLElements with that tag name
     *
     * @throws SAXException
     *             the SAX exception
     */
    public HTMLElement[] getElementsByTagName(String tagName) throws SAXException {
<span class="fc" id="L484">        return getReceivedPage().getElementsByTagName(getDOM(), tagName);</span>
    }

    /**
     * Returns a list of HTML element names contained in this HTML section.
     */
    @Override
    public String[] getElementNames() throws SAXException {
<span class="fc" id="L492">        return getReceivedPage().getElementNames();</span>
    }

    /**
     * Returns the HTMLElements found in this segment with the specified name.
     */
    @Override
    public HTMLElement[] getElementsWithName(String name) throws SAXException {
<span class="fc" id="L500">        return getReceivedPage().getElementsWithName(name);</span>
    }

    /**
     * Returns the HTMLElements found in this segment with the specified class.
     *
     * @param className
     *            the class name
     *
     * @return the elements with class name
     *
     * @throws SAXException
     *             the SAX exception
     */
    public HTMLElement[] getElementsWithClassName(String className) throws SAXException {
<span class="fc" id="L515">        return getReceivedPage().getElementsWithClassName(className);</span>
    }

    /**
     * Returns the HTMLElements found with the specified attribute value.
     */
    @Override
    public HTMLElement[] getElementsWithAttribute(String name, String value) throws SAXException {
<span class="fc" id="L523">        return getReceivedPage().getElementsWithAttribute(name, value);</span>
    }

    /**
     * Returns the forms found in the page in the order in which they appear.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebForm[] getForms() throws SAXException {
<span class="fc" id="L534">        return getReceivedPage().getForms();</span>
    }

    /**
     * Returns the form found in the page with the specified name.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebForm getFormWithName(String name) throws SAXException {
<span class="fc" id="L545">        return getReceivedPage().getFormWithName(name);</span>
    }

    /**
     * Returns the form found in the page with the specified ID.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebForm getFormWithID(String ID) throws SAXException {
<span class="fc" id="L556">        return getReceivedPage().getFormWithID(ID);</span>
    }

    /**
     * Returns the first form found in the page matching the specified criteria.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebForm getFirstMatchingForm(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="fc" id="L567">        return getReceivedPage().getFirstMatchingForm(predicate, criteria);</span>
    }

    /**
     * Returns all forms found in the page matching the specified criteria.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebForm[] getMatchingForms(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="nc" id="L578">        return getReceivedPage().getMatchingForms(predicate, criteria);</span>
    }

    /**
     * Returns the links found in the page in the order in which they appear.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebLink[] getLinks() throws SAXException {
<span class="fc" id="L589">        return getReceivedPage().getLinks();</span>
    }

    /**
     * Returns the first link which contains the specified text.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebLink getLinkWith(String text) throws SAXException {
<span class="fc" id="L600">        return getReceivedPage().getLinkWith(text);</span>
    }

    /**
     * Returns the first link which contains an image with the specified text as its 'alt' attribute.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebLink getLinkWithImageText(String text) throws SAXException {
<span class="fc" id="L611">        return getReceivedPage().getLinkWithImageText(text);</span>
    }

    /**
     * Returns the link found in the page with the specified name.
     *
     * @param name
     *            the name
     *
     * @return the link with name
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     */
    public WebLink getLinkWithName(String name) throws SAXException {
<span class="fc" id="L626">        return getReceivedPage().getLinkWithName(name);</span>
    }

    /**
     * Returns the link found in the page with the specified ID.
     *
     * @param ID
     *            the id
     *
     * @return the link with ID
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     */
    public WebLink getLinkWithID(String ID) throws SAXException {
<span class="fc" id="L641">        return getReceivedPage().getLinkWithID(ID);</span>
    }

    /**
     * Returns the first link found in the page matching the specified criteria.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebLink getFirstMatchingLink(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="fc" id="L652">        return getReceivedPage().getFirstMatchingLink(predicate, criteria);</span>
    }

    /**
     * Returns all links found in the page matching the specified criteria.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebLink[] getMatchingLinks(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="fc" id="L663">        return getReceivedPage().getMatchingLinks(predicate, criteria);</span>
    }

    /**
     * Returns the images found in the page in the order in which they appear.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebImage[] getImages() throws SAXException {
<span class="fc" id="L674">        return getReceivedPage().getImages();</span>
    }

    /**
     * Returns the image found in the page with the specified name attribute.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebImage getImageWithName(String source) throws SAXException {
<span class="fc" id="L685">        return getReceivedPage().getImageWithName(source);</span>
    }

    /**
     * Returns the first image found in the page with the specified src attribute.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebImage getImageWithSource(String source) throws SAXException {
<span class="fc" id="L696">        return getReceivedPage().getImageWithSource(source);</span>
    }

    /**
     * Returns the first image found in the page with the specified alt attribute.
     **/
    @Override
    public WebImage getImageWithAltText(String altText) throws SAXException {
<span class="fc" id="L704">        return getReceivedPage().getImageWithAltText(altText);</span>
    }

    @Override
    public WebApplet[] getApplets() throws SAXException {
<span class="fc" id="L709">        return getReceivedPage().getApplets();</span>
    }

    /**
     * Returns an array of text blocks found in the page.
     */
    @Override
    public TextBlock[] getTextBlocks() throws SAXException {
<span class="fc" id="L717">        return getReceivedPage().getTextBlocks();</span>
    }

    /**
     * Returns the text block after the specified block, if any.
     *
     * @param block
     *            the block
     *
     * @return the next text block
     *
     * @throws SAXException
     *             the SAX exception
     */
    public TextBlock getNextTextBlock(TextBlock block) throws SAXException {
<span class="fc" id="L732">        return getReceivedPage().getNextTextBlock(block);</span>
    }

    /**
     * Returns the first link found in the page matching the specified criteria.
     *
     * @param predicate
     *            the predicate
     * @param criteria
     *            the criteria
     *
     * @return the first matching text block
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     */
    public TextBlock getFirstMatchingTextBlock(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="fc" id="L749">        return getReceivedPage().getFirstMatchingTextBlock(predicate, criteria);</span>
    }

    /**
     * Returns a copy of the domain object model tree associated with this response. If the response is HTML, it will
     * use a special parser which can transform HTML into an XML DOM.
     *
     * @return the dom
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     */
    public Document getDOM() throws SAXException {
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">        if (isHTML()) {</span>
<span class="fc" id="L763">            return (Document) getReceivedPage().getDOM();</span>
        }
        try {
<span class="nc" id="L766">            return HttpUnitUtils.parse(new InputSource(new StringReader(getText())));</span>
<span class="nc" id="L767">        } catch (IOException e) {</span>
<span class="nc" id="L768">            throw new SAXException(e);</span>
        }
    }

    /**
     * Returns the top-level tables found in this page in the order in which they appear.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebTable[] getTables() throws SAXException {
<span class="fc" id="L780">        return getReceivedPage().getTables();</span>
    }

    /**
     * Returns the first table in the response which matches the specified predicate and value. Will recurse into any
     * nested tables, as needed.
     *
     * @return the selected table, or null if none is found
     **/
    @Override
    public WebTable getFirstMatchingTable(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="nc" id="L791">        return getReceivedPage().getFirstMatchingTable(predicate, criteria);</span>
    }

    /**
     * Returns all tables found in the page matching the specified criteria.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     **/
    @Override
    public WebTable[] getMatchingTables(HTMLElementPredicate predicate, Object criteria) throws SAXException {
<span class="nc" id="L802">        return getReceivedPage().getMatchingTables(predicate, criteria);</span>
    }

    /**
     * Returns the first table in the response which has the specified text as the full text of its first non-blank row
     * and non-blank column. Will recurse into any nested tables, as needed. Case is ignored.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     *
     * @return the selected table, or null if none is found
     **/
    @Override
    public WebTable getTableStartingWith(String text) throws SAXException {
<span class="fc" id="L816">        return getReceivedPage().getTableStartingWith(text);</span>
    }

    /**
     * Returns the first table in the response which has the specified text as a prefix of the text of its first
     * non-blank row and non-blank column. Will recurse into any nested tables, as needed. Case is ignored.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     *
     * @return the selected table, or null if none is found
     **/
    @Override
    public WebTable getTableStartingWithPrefix(String text) throws SAXException {
<span class="fc" id="L830">        return getReceivedPage().getTableStartingWithPrefix(text);</span>
    }

    /**
     * Returns the first table in the response which has the specified text as its summary attribute. Will recurse into
     * any nested tables, as needed. Case is ignored.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     *
     * @return the selected table, or null if none is found
     **/
    @Override
    public WebTable getTableWithSummary(String text) throws SAXException {
<span class="fc" id="L844">        return getReceivedPage().getTableWithSummary(text);</span>
    }

    /**
     * Returns the first table in the response which has the specified text as its ID attribute. Will recurse into any
     * nested tables, as needed. Case is ignored.
     *
     * @exception SAXException
     *                thrown if there is an error parsing the response.
     *
     * @return the selected table, or null if none is found
     **/
    @Override
    public WebTable getTableWithID(String text) throws SAXException {
<span class="fc" id="L858">        return getReceivedPage().getTableWithID(text);</span>
    }

    // ---------------------------------------- JavaScript methods ----------------------------------------

    /**
     * get the scriptable object for this WebResponse.
     *
     * @return the scriptable object
     */
    public Scriptable getScriptableObject() {
<span class="fc" id="L869">        ScriptingHandler result = this.getScriptingHandler();</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">        if (!(result instanceof Scriptable)) {</span>
<span class="nc" id="L871">            throw new RuntimeException(</span>
<span class="nc" id="L872">                    &quot;getScriptableObject failed for &quot; + result.getClass().getName() + &quot; - not a Scriptable&quot;);</span>
        }
<span class="fc" id="L874">        return (Scriptable) result;</span>
    }

    /**
     * Sets the scripting handler.
     *
     * @param scriptingHandler
     *            the new scripting handler
     */
    public void setScriptingHandler(ScriptingHandler scriptingHandler) {
<span class="nc" id="L884">        _scriptingHandler = scriptingHandler;</span>
<span class="nc" id="L885">    }</span>

    @Override
    public ScriptingHandler getScriptingHandler() {
<span class="fc bfc" id="L889" title="All 2 branches covered.">        if (_scriptingHandler == null) {</span>
<span class="fc" id="L890">            _scriptingHandler = HttpUnitOptions.getScriptingEngine().createHandler(this);</span>
        }
<span class="fc" id="L892">        return _scriptingHandler;</span>
    }

    /**
     * Creates the javascript scripting handler.
     *
     * @return the scripting handler
     */
    public ScriptingHandler createJavascriptScriptingHandler() {
<span class="fc" id="L901">        return new Scriptable();</span>
    }

    /**
     * create a DOMScriptingHandler.
     *
     * @return the DOM scripting handler (the window)
     */
    public ScriptingHandler createDomScriptingHandler() {
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (!isHTML()) {</span>
<span class="nc" id="L911">            return new DomWindow(this);</span>
        }
        try {
<span class="nc" id="L914">            HTMLPage page = this.getReceivedPage();</span>
<span class="nc" id="L915">            Node rootNode = page.getRootNode();</span>
<span class="nc" id="L916">            HTMLDocumentImpl document = (HTMLDocumentImpl) rootNode;</span>
<span class="nc" id="L917">            DomWindow result = document.getWindow();</span>
<span class="nc" id="L918">            result.setProxy(this);</span>
<span class="nc" id="L919">            return result;</span>
<span class="nc" id="L920">        } catch (SAXException e) {</span>
<span class="nc" id="L921">            return new DomWindow(this);</span>
        }
    }

    /**
     * New delegate.
     *
     * @param delegateClassName
     *            the delegate class name
     *
     * @return the scriptable delegate
     */
    public static ScriptableDelegate newDelegate(String delegateClassName) {
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        if (delegateClassName.equalsIgnoreCase(&quot;Option&quot;)) {</span>
<span class="fc" id="L935">            return FormControl.newSelectionOption();</span>
        }
<span class="nc" id="L937">        throw new IllegalArgumentException(&quot;No such scripting class supported: &quot; + delegateClassName);</span>
    }

    /**
     * Gets the document scriptable.
     *
     * @return the document scriptable
     */
    HTMLPage.Scriptable getDocumentScriptable() {
<span class="fc" id="L946">        return getScriptableObject().getDocument();</span>
    }

    /**
     * open a a new Window with the given name and relative URL
     *
     * @param name
     *            - the name of the window
     * @param relativeUrl
     *            - the relative URL to be used
     *
     * @return the WebResponse as a DomWindowProxy
     */
    @Override
    public DomWindowProxy openNewWindow(String name, String relativeUrl) throws IOException, SAXException {
<span class="fc bfc" id="L961" title="All 4 branches covered.">        if (relativeUrl == null || relativeUrl.trim().isEmpty()) {</span>
<span class="fc" id="L962">            relativeUrl = &quot;about:&quot;;</span>
        }
<span class="fc" id="L964">        GetMethodWebRequest request = new GetMethodWebRequest(getURL(), relativeUrl, _frame, name);</span>
<span class="fc" id="L965">        return _window.getResponse(request);</span>
    }

    @Override
    public DomWindowProxy submitRequest(HTMLElementImpl sourceElement, String method, String location, String target,
            MessageBody requestBody) throws IOException, SAXException {
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">        if (method.equalsIgnoreCase(&quot;get&quot;)) {</span>
<span class="fc" id="L972">            return getWindow().sendRequest(new GetMethodWebRequest(this, sourceElement, getURL(), location, target));</span>
        }
<span class="nc" id="L974">        return null;</span>
    }

    @Override
    public void close() {
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">        if (getFrameName().equals(WebRequest.TOP_FRAME)) {</span>
<span class="fc" id="L980">            _window.close();</span>
        }
<span class="fc" id="L982">    }</span>

    @Override
    public void alert(String message) {
<span class="fc" id="L986">        _client.postAlert(message);</span>
<span class="fc" id="L987">    }</span>

    @Override
    public boolean confirm(String message) {
<span class="fc" id="L991">        return _client.getConfirmationResponse(message);</span>
    }

    @Override
    public String prompt(String prompt, String defaultResponse) {
<span class="fc" id="L996">        return _client.getUserResponse(prompt, defaultResponse);</span>
    }

    /**
     * Gets the base target.
     *
     * @return the base target
     */
    String getBaseTarget() {
<span class="fc" id="L1005">        return _baseTarget;</span>
    }

    /**
     * The Class Scriptable.
     */
<span class="fc" id="L1011">    public class Scriptable extends ScriptableDelegate implements NamedDelegate {</span>

        /**
         * Alert user.
         *
         * @param message
         *            the message
         */
        public void alertUser(String message) {
<span class="fc" id="L1020">            alert(message);</span>
<span class="fc" id="L1021">        }</span>

        /**
         * Gets the confirmation response.
         *
         * @param message
         *            the message
         *
         * @return the confirmation response
         */
        public boolean getConfirmationResponse(String message) {
<span class="fc" id="L1032">            return confirm(message);</span>
        }

        /**
         * Gets the user response.
         *
         * @param prompt
         *            the prompt
         * @param defaultResponse
         *            the default response
         *
         * @return the user response
         */
        public String getUserResponse(String prompt, String defaultResponse) {
<span class="fc" id="L1046">            return prompt(prompt, defaultResponse);</span>
        }

        /**
         * Gets the client properties.
         *
         * @return the client properties
         */
        public ClientProperties getClientProperties() {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            return _client == null ? ClientProperties.getDefaultProperties() : _client.getClientProperties();</span>
        }

        /**
         * Gets the document.
         *
         * @return the document
         */
        public HTMLPage.Scriptable getDocument() {
            try {
<span class="fc bfc" id="L1065" title="All 2 branches covered.">                if (!isHTML()) {</span>
<span class="fc" id="L1066">                    replaceText(BLANK_HTML, HTML_CONTENT);</span>
                }
<span class="fc" id="L1068">                return getReceivedPage().getScriptableObject();</span>
<span class="nc" id="L1069">            } catch (SAXException e) {</span>
<span class="nc" id="L1070">                throw new RuntimeException(e.toString());</span>
            }
        }

        /**
         * Gets the frames.
         *
         * @return the frames
         *
         * @throws SAXException
         *             the SAX exception
         */
        public Scriptable[] getFrames() throws SAXException {
<span class="fc" id="L1083">            String[] names = getFrameNames();</span>
<span class="fc" id="L1084">            Scriptable[] frames = new Scriptable[names.length];</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">            for (int i = 0; i &lt; frames.length; i++) {</span>
<span class="fc" id="L1086">                frames[i] = getSubframeContents(names[i]).getScriptableObject();</span>
            }
<span class="fc" id="L1088">            return frames;</span>
        }

        /**
         * Load.
         *
         * @throws SAXException
         *             the SAX exception
         */
        public void load() throws SAXException {
<span class="pc bpc" id="L1098" title="1 of 4 branches missed.">            if (isHTML() &amp;&amp; isWithParse()) {</span>
<span class="fc" id="L1099">                getReceivedPage().getForms(); // TODO be more explicit here - don't care about forms, after all</span>
<span class="fc" id="L1100">                doEventScript(getReceivedPage().getOnLoadEvent());</span>
            }
<span class="fc" id="L1102">        }</span>

        /**
         * Open.
         *
         * @param urlString
         *            the url string
         * @param name
         *            the name
         * @param features
         *            the features
         * @param replace
         *            the replace
         *
         * @return the scriptable
         *
         * @throws IOException
         *             Signals that an I/O exception has occurred.
         * @throws SAXException
         *             the SAX exception
         */
        public Scriptable open(String urlString, String name, String features, boolean replace)
                throws IOException, SAXException {
<span class="fc" id="L1125">            WebResponse response = (WebResponse) openNewWindow(name, urlString);</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">            return response == null ? null : response.getScriptableObject();</span>
        }

        /**
         * Close window.
         */
        public void closeWindow() {
<span class="fc" id="L1133">            close();</span>
<span class="fc" id="L1134">        }</span>

        /**
         * Returns the value of the named property. Will return null if the property does not exist.
         **/
        @Override
        public Object get(String propertyName) {
<span class="fc bfc" id="L1141" title="All 2 branches covered.">            if (propertyName.equals(&quot;name&quot;)) {</span>
<span class="fc" id="L1142">                return getName();</span>
            }
<span class="fc bfc" id="L1144" title="All 2 branches covered.">            if (propertyName.equalsIgnoreCase(&quot;top&quot;)) {</span>
<span class="fc" id="L1145">                return _window.getFrameContents(WebRequest.TOP_FRAME).getScriptableObject();</span>
            }
<span class="fc bfc" id="L1147" title="All 2 branches covered.">            if (propertyName.equalsIgnoreCase(&quot;parent&quot;)) {</span>
<span class="fc" id="L1148">                return _window.getParentFrameContents(_frame).getScriptableObject();</span>
            }
<span class="fc bfc" id="L1150" title="All 2 branches covered.">            if (propertyName.equalsIgnoreCase(&quot;opener&quot;)) {</span>
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">                return getFrameName().equals(WebRequest.TOP_FRAME) ? getScriptable(_window.getOpener()) : null;</span>
            }
<span class="fc bfc" id="L1153" title="All 2 branches covered.">            if (propertyName.equalsIgnoreCase(&quot;closed&quot;)) {</span>
<span class="pc bpc" id="L1154" title="1 of 4 branches missed.">                return getFrameName().equals(WebRequest.TOP_FRAME) &amp;&amp; _window.isClosed() ? Boolean.TRUE : Boolean.FALSE;</span>
            }
            try {
<span class="fc" id="L1157">                return getSubframeContents(propertyName).getScriptableObject();</span>
<span class="fc" id="L1158">            } catch (NoSuchFrameException e) {</span>
<span class="fc" id="L1159">                return super.get(propertyName);</span>
            }
        }

        @Override
        public String getName() {
<span class="fc bfc" id="L1165" title="All 2 branches covered.">            String windowName = getFrameName().equals(WebRequest.TOP_FRAME) ? _window.getName() : getFrameName();</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">            return windowName.startsWith(WebWindow.NO_NAME) ? &quot;&quot; : windowName;</span>
        }

        /**
         * Gets the scriptable.
         *
         * @param opener
         *            the opener
         *
         * @return the scriptable
         */
        private Scriptable getScriptable(WebResponse opener) {
<span class="fc bfc" id="L1178" title="All 2 branches covered.">            return opener == null ? null : opener.getScriptableObject();</span>
        }

        /**
         * Sets the value of the named property. Will throw a runtime exception if the property does not exist or cannot
         * accept the specified value.
         **/
        @Override
        public void set(String propertyName, Object value) {
<span class="pc bpc" id="L1187" title="1 of 2 branches missed.">            if (propertyName.equals(&quot;name&quot;)) {</span>
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L1189">                    value = &quot;&quot;;</span>
                }
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">                if (getFrameName().equals(WebRequest.TOP_FRAME)) {</span>
<span class="fc" id="L1192">                    _window.setName(value.toString());</span>
                }
            } else {
<span class="nc" id="L1195">                super.set(propertyName, value);</span>
            }
<span class="fc" id="L1197">        }</span>

        /**
         * Sets the location.
         *
         * @param relativeURL
         *            the new location
         *
         * @throws IOException
         *             Signals that an I/O exception has occurred.
         * @throws SAXException
         *             the SAX exception
         */
        public void setLocation(String relativeURL) throws IOException, SAXException {
<span class="fc" id="L1211">            getWindow().getResponse(new GetMethodWebRequest(_pageURL, relativeURL, _frame.getName()));</span>
<span class="fc" id="L1212">        }</span>

        /**
         * Gets the url.
         *
         * @return the url
         */
        public URL getURL() {
<span class="fc" id="L1220">            return WebResponse.this._pageURL;</span>
        }
    }

    // ---------------------------------------- Object methods --------------------------------------------

    @Override
    public abstract String toString();

    // ----------------------------------------- protected members -----------------------------------------------

    /**
     * Constructs a response object. see [ 1159858 ] patch for RFE 1159844 (parsing intercepted pages)
     *
     * @param client
     *            the client
     * @param frame
     *            the frame to hold the response
     * @param url
     *            the url from which the response was received
     */
<span class="fc" id="L1241">    protected WebResponse(WebClient client, FrameSelector frame, URL url) {</span>
<span class="fc" id="L1242">        _client = client;</span>
<span class="fc" id="L1243">        _baseURL = _pageURL = url;</span>
<span class="fc" id="L1244">        _baseTarget = frame.getName();</span>
<span class="fc" id="L1245">        _frame = frame;</span>
        // intialize window for interception as described in
        // https://sourceforge.net/tracker/index.php?func=detail&amp;aid=1159844&amp;group_id=6550&amp;atid=356550
<span class="fc bfc" id="L1248" title="All 2 branches covered.">        if (client != null) {</span>
<span class="fc" id="L1249">            _window = client.getMainWindow();</span>
        }
<span class="fc" id="L1251">    }</span>

    /**
     * Constructs a response object.
     *
     * @param client
     *            the client
     * @param frame
     *            the frame to hold the response
     * @param url
     *            the url from which the response was received
     * @param text
     *            the text
     */
    protected WebResponse(WebClient client, FrameSelector frame, URL url, String text) {
<span class="fc" id="L1266">        this(client, frame, url);</span>
<span class="fc" id="L1267">        _responseText = text;</span>
<span class="fc" id="L1268">    }</span>

    /**
     * Define raw input stream.
     *
     * @param inputStream
     *            the input stream
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    protected final void defineRawInputStream(InputStream inputStream) throws IOException {
<span class="pc bpc" id="L1280" title="2 of 4 branches missed.">        if (_inputStream != null || _responseText != null) {</span>
<span class="nc" id="L1281">            throw new IllegalStateException(&quot;Must be called before response text is defined.&quot;);</span>
        }

        // please note bug report [ 1119205 ] EOFExceptions while using a Proxy
        // and patch proposal below
        // by Ralf Bust
        /*
         * original 1.6.2 code if (encodedUsingGZIP()) { byte[] compressedData = readFromStream( inputStream,
         * getContentLength() ); _inputStream = new GZIPInputStream( new ByteArrayInputStream( compressedData ) ); }
         * else { _inputStream = inputStream; }
         */

<span class="fc bfc" id="L1293" title="All 2 branches covered.">        if (encodedUsingGZIP()) {</span>
            try {
<span class="fc" id="L1295">                _inputStream = new GZIPInputStream(inputStream);</span>
<span class="nc" id="L1296">            } catch (EOFException eof) {</span>
<span class="nc" id="L1297">                _inputStream = inputStream;</span>
<span class="pc" id="L1298">            }</span>
        } else {
<span class="fc" id="L1300">            _inputStream = inputStream;</span>
        }
<span class="fc" id="L1302">    }</span>

    /**
     * Encoded using GZIP.
     *
     * @return true, if successful
     */
    private boolean encodedUsingGZIP() {
<span class="fc" id="L1310">        String encoding = getHeaderField(&quot;Content-Encoding&quot;);</span>
<span class="pc bpc" id="L1311" title="1 of 4 branches missed.">        return encoding != null &amp;&amp; encoding.indexOf(&quot;gzip&quot;) &gt;= 0;</span>
    }

    /**
     * Overwrites the current value (if any) of the content type header.
     *
     * @param value
     *            the new content type header
     */
    protected void setContentTypeHeader(String value) {
<span class="fc" id="L1321">        _contentHeader = value;</span>
<span class="fc" id="L1322">    }</span>

    // ------------------------------------------ package members ------------------------------------------------

    /** The Constant BLANK_HTML. */
    static final String BLANK_HTML = &quot;&quot;;

    /**
     * Creates the blank response.
     *
     * @return the web response
     */
    static WebResponse createBlankResponse() {
<span class="fc" id="L1335">        return new DefaultWebResponse(BLANK_HTML);</span>
    }

    /**
     * Gets the window.
     *
     * @return the window
     */
    WebWindow getWindow() {
<span class="fc" id="L1344">        return _window;</span>
    }

    /**
     * Sets the window.
     *
     * @param window
     *            the new window
     */
    void setWindow(WebWindow window) {
<span class="fc" id="L1354">        _window = window;</span>
<span class="fc" id="L1355">    }</span>

    /**
     * replace the given text
     *
     * @param text
     *            - the text to replace
     * @param contentType
     *            - the contenttype
     */
    @Override
    public boolean replaceText(String text, String contentType) {
<span class="fc bfc" id="L1367" title="All 2 branches covered.">        if (_parsingPage) {</span>
<span class="fc" id="L1368">            return false;</span>
        }
<span class="fc" id="L1370">        _responseText = text;</span>
<span class="fc" id="L1371">        _inputStream = null;</span>
<span class="fc" id="L1372">        _page = null;</span>
<span class="fc" id="L1373">        _contentType = contentType;</span>
<span class="fc" id="L1374">        _baseURL = null;</span>
<span class="fc" id="L1375">        _baseTarget = _frame.getName();</span>
<span class="fc" id="L1376">        _refreshHeader = null;</span>

        try {
<span class="fc" id="L1379">            readTags(text.getBytes(StandardCharsets.UTF_8));</span>
<span class="nc" id="L1380">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L1381">            throw new RuntimeException(&quot;Failure while attempting to reparse text: &quot; + e);</span>
<span class="fc" id="L1382">        }</span>
<span class="fc" id="L1383">        return true;</span>
    }

    /**
     * Returns the frames found in the page in the order in which they appear.
     *
     * @return the frame requests
     *
     * @throws SAXException
     *             the SAX exception
     */
    WebRequest[] getFrameRequests() throws SAXException {
<span class="fc" id="L1395">        WebFrame[] frames = getFrames();</span>
<span class="fc" id="L1396">        List&lt;WebRequest&gt; requests = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">        for (WebFrame frame : frames) {</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">            if (frame.hasInitialRequest()) {</span>
<span class="fc" id="L1399">                requests.add(frame.getInitialRequest());</span>
            }
        }

<span class="fc" id="L1403">        return requests.toArray(new WebRequest[requests.size()]);</span>
    }

    // --------------------------------- private members --------------------------------------

    /** The window. */
    private WebWindow _window;

    /** The page. */
    private HTMLPage _page;

    /** The content header. */
    private String _contentHeader;

    /** The content length. */
<span class="fc" id="L1418">    private int _contentLength = UNINITIALIZED_INT;</span>

    /** The content type. */
    private String _contentType;

    /** The character set. */
    private String _characterSet;

    /** The refresh request. */
    private WebRequest _refreshRequest;

    /** The refresh delay. */
<span class="fc" id="L1430">    private int _refreshDelay = -1; // initialized to invalid value</span>

    /** the response as a String. */
    private String _responseText;

    /** the response as a byte array. */
    private byte[] _bytes;

    /** The input stream. */
    private InputStream _inputStream;

    /** The page URL. */
    private final URL _pageURL;

    /** The client. */
    private final WebClient _client;

    /**
     * getter for the WebClient.
     *
     * @return the web client for this WebResponse (if any)
     */
    public WebClient getClient() {
<span class="nc" id="L1453">        return _client;</span>
    }

    /** The scripting handler. */
    private ScriptingHandler _scriptingHandler;

    /**
     * Load response text.
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    protected void loadResponseText() throws IOException {
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">        if (_responseText != null) {</span>
<span class="nc" id="L1467">            throw new IllegalStateException(&quot;May only invoke loadResponseText once&quot;);</span>
        }
<span class="fc" id="L1469">        _responseText = &quot;&quot;;</span>

<span class="fc" id="L1471">        try (InputStream inputStream = getInputStream()) {</span>
<span class="fc bfc" id="L1472" title="All 2 branches covered.">            final int contentLength = this.encodedUsingGZIP() ? -1 : getContentLength();</span>
<span class="fc bfc" id="L1473" title="All 2 branches covered.">            int bytesRemaining = contentLength &lt; 0 ? Integer.MAX_VALUE : contentLength;</span>
<span class="fc" id="L1474">            _bytes = readFromStream(inputStream, bytesRemaining);</span>

<span class="fc" id="L1476">            readTags(_bytes);</span>
<span class="fc" id="L1477">            _responseText = new String(_bytes, Charset.forName(getCharacterSet()));</span>
<span class="fc" id="L1478">            _inputStream = new ByteArrayInputStream(_bytes);</span>

<span class="pc bpc" id="L1480" title="5 of 6 branches missed.">            if (HttpUnitOptions.isCheckContentLength() &amp;&amp; contentLength &gt;= 0 &amp;&amp; _bytes.length != contentLength) {</span>
<span class="nc" id="L1481">                throw new IOException(</span>
                        &quot;Truncated message. Expected length: &quot; + contentLength + &quot;, Actual length: &quot; + _bytes.length);
            }
        }
<span class="fc" id="L1485">    }</span>

    /**
     * Read from stream.
     *
     * @param inputStream
     *            the input stream
     * @param maxBytes
     *            the max bytes
     *
     * @return the byte[]
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private byte[] readFromStream(InputStream inputStream, int maxBytes) throws IOException {
<span class="fc" id="L1501">        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
<span class="fc" id="L1502">        byte[] buffer = new byte[8 * 1024];</span>
<span class="fc" id="L1503">        int count = 0;</span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">        if (maxBytes &gt; 0) {</span>
            do {
<span class="fc" id="L1506">                outputStream.write(buffer, 0, count);</span>
<span class="fc" id="L1507">                maxBytes -= count;</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">                if (maxBytes &lt;= 0) {</span>
<span class="fc" id="L1509">                    break;</span>
                }
<span class="fc" id="L1511">                count = inputStream.read(buffer, 0, Math.min(maxBytes, buffer.length));</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">            } while (count != -1);</span>
        } else {
            do {
<span class="fc" id="L1515">                outputStream.write(buffer, 0, count);</span>
<span class="fc" id="L1516">                int available = getAvailableBytes(inputStream);</span>
<span class="pc bpc" id="L1517" title="1 of 2 branches missed.">                count = available == 0 ? -1 : inputStream.read(buffer, 0, buffer.length);</span>
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">            } while (count != -1);</span>
        }

<span class="fc" id="L1521">        return outputStream.toByteArray();</span>
    }

    /**
     * Gets the available bytes.
     *
     * @param inputStream
     *            the input stream
     *
     * @return the available bytes
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    private int getAvailableBytes(InputStream inputStream) throws IOException {
<span class="fc" id="L1536">        int timeLeft = UNKNOWN_LENGTH_TIMEOUT;</span>
        int available;
        do {
<span class="fc" id="L1539">            timeLeft -= UNKNOWN_LENGTH_RETRY_INTERVAL;</span>
            try {
<span class="fc" id="L1541">                Thread.sleep(UNKNOWN_LENGTH_RETRY_INTERVAL);</span>
<span class="nc" id="L1542">            } catch (InterruptedException e) {</span>
<span class="nc" id="L1543">                Thread.interrupted();</span>
                /* do nothing */
<span class="fc" id="L1545">            }</span>
<span class="fc" id="L1546">            available = inputStream.available();</span>
<span class="pc bpc" id="L1547" title="1 of 4 branches missed.">        } while (available == 0 &amp;&amp; timeLeft &gt; 0);</span>
<span class="fc" id="L1548">        return available;</span>
    }

    /**
     * read the tags from the given message.
     *
     * @param rawMessage
     *            the raw message
     *
     * @throws MalformedURLException
     *             the malformed URL exception
     */
    private void readTags(byte[] rawMessage) throws MalformedURLException {
<span class="fc" id="L1561">        ByteTagParser parser = new ByteTagParser(rawMessage);</span>
<span class="fc" id="L1562">        ByteTag tag = parser.getNextTag();</span>
<span class="fc bfc" id="L1563" title="All 2 branches covered.">        while (tag != null) {</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">            if (tag.getName().equalsIgnoreCase(&quot;meta&quot;)) {</span>
<span class="fc" id="L1565">                processMetaTag(tag);</span>
            }
<span class="fc bfc" id="L1567" title="All 2 branches covered.">            if (tag.getName().equalsIgnoreCase(&quot;base&quot;)) {</span>
<span class="fc" id="L1568">                processBaseTag(tag);</span>
            }
            // loop over a noscript region
<span class="fc bfc" id="L1571" title="All 4 branches covered.">            if (tag.getName().equalsIgnoreCase(&quot;noscript&quot;) &amp;&amp; HttpUnitOptions.isScriptingEnabled()) {</span>
                do {
<span class="fc" id="L1573">                    tag = parser.getNextTag();</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">                } while (!tag.getName().equalsIgnoreCase(&quot;/noscript&quot;));</span>
            }
<span class="fc" id="L1576">            tag = parser.getNextTag();</span>
        }
<span class="fc" id="L1578">    }</span>

    /**
     * Process base tag.
     *
     * @param tag
     *            the tag
     *
     * @throws MalformedURLException
     *             the malformed URL exception
     */
    private void processBaseTag(ByteTag tag) throws MalformedURLException {
<span class="fc bfc" id="L1590" title="All 2 branches covered.">        if (tag.getAttribute(&quot;href&quot;) != null) {</span>
<span class="fc" id="L1591">            _baseURL = new URL(getURL(), tag.getAttribute(&quot;href&quot;));</span>
        }
<span class="fc bfc" id="L1593" title="All 2 branches covered.">        if (tag.getAttribute(&quot;target&quot;) != null) {</span>
<span class="fc" id="L1594">            _baseTarget = tag.getAttribute(&quot;target&quot;);</span>
        }
<span class="fc" id="L1596">    }</span>

    /**
     * process MetaTags based on the tag.
     *
     * @param tag
     *            the tag
     */
    private void processMetaTag(ByteTag tag) {
<span class="fc bfc" id="L1605" title="All 2 branches covered.">        if (isHttpEquivMetaTag(tag, &quot;content-type&quot;)) {</span>
<span class="fc" id="L1606">            inferContentType(tag.getAttribute(&quot;content&quot;));</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">        } else if (isHttpEquivMetaTag(tag, &quot;refresh&quot;)) {</span>
<span class="fc" id="L1608">            inferRefreshHeader(tag.getAttribute(&quot;content&quot;));</span>
        }
<span class="fc" id="L1610">    }</span>

    /**
     * check whether the given tag is a http equiv meta tag.
     *
     * @param tag
     *            the tag
     * @param headerName
     *            the header name
     *
     * @return true, if is http equiv meta tag
     */
    private boolean isHttpEquivMetaTag(ByteTag tag, String headerName) {
<span class="fc" id="L1623">        String equiv1 = tag.getAttribute(&quot;http_equiv&quot;);</span>
<span class="fc" id="L1624">        String equiv2 = tag.getAttribute(&quot;http-equiv&quot;);</span>
<span class="fc bfc" id="L1625" title="All 4 branches covered.">        return headerName.equalsIgnoreCase(equiv1) || headerName.equalsIgnoreCase(equiv2);</span>
    }

    /**
     * infer the refresh Header.
     *
     * @param refreshHeader
     *            the refresh header
     */
    private void inferRefreshHeader(String refreshHeader) {
<span class="fc" id="L1635">        String originalHeader = getHeaderField(&quot;Refresh&quot;);</span>
        // System.err.println(&quot;original='&quot;+originalHeader+&quot;'\nrefreshHeader='&quot;+refreshHeader+&quot;'&quot;);
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">        if (originalHeader == null) {</span>
<span class="fc" id="L1638">            _refreshHeader = refreshHeader;</span>
        }
<span class="fc" id="L1640">    }</span>

    /**
     * read the Refresh Request.
     */
    private void readRefreshRequest() {
<span class="fc bfc" id="L1646" title="All 2 branches covered.">        if (_refreshDelay &gt;= 0) {</span>
<span class="fc" id="L1647">            return;</span>
        }
<span class="fc" id="L1649">        _refreshDelay = 0;</span>
<span class="fc bfc" id="L1650" title="All 2 branches covered.">        String refreshHeader = _refreshHeader != null ? _refreshHeader : getHeaderField(&quot;Refresh&quot;);</span>
<span class="fc bfc" id="L1651" title="All 2 branches covered.">        if (refreshHeader == null) {</span>
<span class="fc" id="L1652">            return;</span>
        }

<span class="fc" id="L1655">        int semicolonIndex = refreshHeader.indexOf(';');</span>
<span class="fc bfc" id="L1656" title="All 2 branches covered.">        if (semicolonIndex &lt; 0) {</span>
<span class="fc" id="L1657">            interpretRefreshHeaderElement(refreshHeader, refreshHeader);</span>
        } else {
<span class="fc" id="L1659">            interpretRefreshHeaderElement(refreshHeader.substring(0, semicolonIndex), refreshHeader);</span>
<span class="fc" id="L1660">            interpretRefreshHeaderElement(refreshHeader.substring(semicolonIndex + 1), refreshHeader);</span>
        }
<span class="fc bfc" id="L1662" title="All 2 branches covered.">        if (_refreshRequest == null) {</span>
<span class="fc" id="L1663">            _refreshRequest = new GetMethodWebRequest(_pageURL, _pageURL.toString(), _frame.getName());</span>
        }
<span class="fc" id="L1665">    }</span>

    /**
     * Interpret refresh header element.
     *
     * @param token
     *            the token
     * @param refreshHeader
     *            the refresh header
     */
    private void interpretRefreshHeaderElement(String token, String refreshHeader) {
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">        if (token.isEmpty()) {</span>
<span class="nc" id="L1677">            return;</span>
        }
        try {
<span class="fc bfc" id="L1680" title="All 2 branches covered.">            if (Character.isDigit(token.charAt(0))) {</span>
<span class="fc" id="L1681">                _refreshDelay = Integer.parseInt(token);</span>
            } else {
<span class="fc" id="L1683">                _refreshRequest = new GetMethodWebRequest(_pageURL, getRefreshURL(token), _frame.getName());</span>
            }
<span class="nc" id="L1685">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L1686">            System.out.println(&quot;Unable to interpret refresh tag: \&quot;&quot; + refreshHeader + '&quot;');</span>
<span class="fc" id="L1687">        }</span>
<span class="fc" id="L1688">    }</span>

    /**
     * Gets the refresh URL.
     *
     * @param text
     *            the text
     *
     * @return the refresh URL
     */
    private String getRefreshURL(String text) {
<span class="fc" id="L1699">        text = text.trim();</span>
<span class="fc bfc" id="L1700" title="All 2 branches covered.">        if (!text.toUpperCase().startsWith(&quot;URL&quot;)) {</span>
<span class="fc" id="L1701">            return HttpUnitUtils.stripQuotes(text);</span>
        }
<span class="fc" id="L1703">        int splitIndex = text.indexOf('=');</span>
<span class="fc" id="L1704">        String value = text.substring(splitIndex + 1).trim();</span>
<span class="fc" id="L1705">        return HttpUnitUtils.replaceEntities(HttpUnitUtils.stripQuotes(value));</span>
    }

    /**
     * Infer content type.
     *
     * @param contentTypeHeader
     *            the content type header
     */
    private void inferContentType(String contentTypeHeader) {
<span class="fc" id="L1715">        String originalHeader = getHeaderField(&quot;Content-type&quot;);</span>
<span class="pc bpc" id="L1716" title="2 of 4 branches missed.">        if (originalHeader == null || originalHeader.indexOf(&quot;charset&quot;) &lt; 0) {</span>
<span class="fc" id="L1717">            setContentTypeHeader(contentTypeHeader);</span>
        }
<span class="fc" id="L1719">    }</span>

    /**
     * Gets the cookie jar.
     *
     * @return the cookie jar
     */
    CookieJar getCookieJar() {
<span class="fc bfc" id="L1727" title="All 2 branches covered.">        if (_cookies == null) {</span>
<span class="fc" id="L1728">            _cookies = new CookieJar(this);</span>
        }
<span class="fc" id="L1730">        return _cookies;</span>
    }

    /** The cookies. */
    private CookieJar _cookies;

    /**
     * Read content type header.
     */
    private void readContentTypeHeader() {
<span class="fc bfc" id="L1740" title="All 2 branches covered.">        String contentHeader = _contentHeader != null ? _contentHeader : getHeaderField(&quot;Content-type&quot;);</span>
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">        if (contentHeader == null) {</span>
<span class="nc" id="L1742">            _contentType = HttpUnitOptions.getDefaultContentType();</span>
<span class="nc" id="L1743">            setCharacterSet(HttpUnitOptions.getDefaultCharacterSet());</span>
<span class="nc" id="L1744">            _contentHeader = _contentType + &quot;;charset=&quot; + _characterSet;</span>
        } else {
<span class="fc" id="L1746">            String[] parts = HttpUnitUtils.parseContentTypeHeader(contentHeader);</span>
<span class="fc bfc" id="L1747" title="All 4 branches covered.">            if (null != _client &amp;&amp; null != _client.getClientProperties().getOverrideContentType()) {</span>
<span class="fc" id="L1748">                _contentType = _client.getClientProperties().getOverrideContentType();</span>
            } else {
<span class="fc" id="L1750">                _contentType = parts[0];</span>
            }
<span class="fc bfc" id="L1752" title="All 2 branches covered.">            if (parts[1] != null) {</span>
<span class="fc" id="L1753">                setCharacterSet(parts[1]);</span>
            }
        }
<span class="fc" id="L1756">    }</span>

    /**
     * Gets the frames.
     *
     * @return the frames
     *
     * @throws SAXException
     *             the SAX exception
     */
    private WebFrame[] getFrames() throws SAXException {
<span class="fc bfc" id="L1767" title="All 2 branches covered.">        if (isWithParse()) {</span>
<span class="fc" id="L1768">            return getReceivedPage().getFrames();</span>
        }
<span class="fc" id="L1770">        return new WebFrame[0];</span>
    }

    /**
     * get the received Page.
     *
     * @return the received page
     *
     * @throws SAXException
     *             the SAX exception
     */
    HTMLPage getReceivedPage() throws SAXException {
<span class="fc bfc" id="L1782" title="All 2 branches covered.">        if (_page == null) {</span>
            try {
<span class="fc" id="L1784">                _parsingPage = true;</span>
<span class="fc bfc" id="L1785" title="All 4 branches covered.">                if (HttpUnitOptions.isCheckHtmlContentType() &amp;&amp; !isHTML()) {</span>
<span class="fc" id="L1786">                    throw new NotHTMLException(getContentType());</span>
                }
<span class="fc" id="L1788">                _page = new HTMLPage(this, _frame, _baseURL, _baseTarget, getCharacterSet());</span>
<span class="pc bpc" id="L1789" title="1 of 2 branches missed.">                if (_withParse) {</span>
<span class="fc" id="L1790">                    _page.parse(getText(), _pageURL);</span>
<span class="pc bpc" id="L1791" title="1 of 2 branches missed.">                    if (_page == null) {</span>
<span class="nc" id="L1792">                        throw new IllegalStateException(&quot;replaceText called in the middle of getReceivedPage()&quot;);</span>
                    }
<span class="fc" id="L1794">                    ((HTMLDocumentImpl) _page.getRootNode()).getWindow().setProxy(this);</span>
                }
<span class="nc" id="L1796">            } catch (IOException e) {</span>
<span class="nc" id="L1797">                HttpUnitUtils.handleException(e);</span>
<span class="nc" id="L1798">                throw new RuntimeException(e.toString());</span>
            } finally {
<span class="fc" id="L1800">                _parsingPage = false;</span>
            }
        }
<span class="fc" id="L1803">        return _page;</span>
    }

    /** The default encoding. */
    private static String _defaultEncoding;

    /** The Constant DEFAULT_ENCODING_CANDIDATES. */
<span class="fc" id="L1810">    private static final String[] DEFAULT_ENCODING_CANDIDATES = { StandardCharsets.ISO_8859_1.name(),</span>
<span class="fc" id="L1811">            StandardCharsets.US_ASCII.name() };</span>

    /**
     * Gets the default encoding.
     *
     * @return the default encoding
     */
    static String getDefaultEncoding() {
<span class="fc bfc" id="L1819" title="All 2 branches covered.">        if (_defaultEncoding == null) {</span>
<span class="pc bpc" id="L1820" title="1 of 2 branches missed.">            for (String element : DEFAULT_ENCODING_CANDIDATES) {</span>
<span class="pc bpc" id="L1821" title="1 of 2 branches missed.">                if (isSupportedCharacterSet(element)) {</span>
<span class="fc" id="L1822">                    return _defaultEncoding = element;</span>
                }
            }
<span class="nc" id="L1825">            _defaultEncoding = Charset.defaultCharset().displayName();</span>
        }
<span class="fc" id="L1827">        return _defaultEncoding;</span>
    }

    /**
     * Sets the character set.
     *
     * @param characterSet
     *            the new character set
     */
    private void setCharacterSet(String characterSet) {
<span class="fc bfc" id="L1837" title="All 2 branches covered.">        if (characterSet == null) {</span>
<span class="fc" id="L1838">            return;</span>
        }

<span class="fc bfc" id="L1841" title="All 2 branches covered.">        _characterSet = isSupportedCharacterSet(characterSet) ? characterSet : getDefaultEncoding();</span>
<span class="fc" id="L1842">    }</span>

    /**
     * Checks if is supported character set.
     *
     * @param characterSet
     *            the character set
     *
     * @return true, if is supported character set
     */
    private static boolean isSupportedCharacterSet(String characterSet) {
        try {
<span class="pc bpc" id="L1854" title="1 of 2 branches missed.">            return &quot;abcd&quot;.getBytes(Charset.forName(characterSet)).length &gt; 0;</span>
<span class="fc" id="L1855">        } catch (UnsupportedCharsetException e) {</span>
<span class="fc" id="L1856">            return false;</span>
        }
    }

    /**
     * Sets the cookie.
     *
     * @param name
     *            the name
     * @param value
     *            the value
     */
    void setCookie(String name, String value) {
<span class="fc" id="L1869">        _client.putCookie(name, value);</span>
<span class="fc" id="L1870">    }</span>

    /**
     * Gets the cookie header.
     *
     * @return the cookie header
     */
    String getCookieHeader() {
<span class="fc" id="L1878">        return _client.getCookieJar().getCookieHeaderField(getURL());</span>
    }

    /**
     * Gets the referer.
     *
     * @return the referer
     */
    String getReferer() {
<span class="fc" id="L1887">        return null;</span>
    }

    // =======================================================================================

    /**
     * The Class ByteTag.
     */
    static class ByteTag {

        /**
         * Instantiates a new byte tag.
         *
         * @param buffer
         *            the buffer
         * @param start
         *            the start
         * @param length
         *            the length
         */
<span class="fc" id="L1907">        ByteTag(byte[] buffer, int start, int length) {</span>
<span class="fc" id="L1908">            _buffer = new String(buffer, start, length, Charset.forName(WebResponse.getDefaultEncoding()))</span>
<span class="fc" id="L1909">                    .toCharArray();</span>
<span class="fc" id="L1910">            _name = nextToken();</span>

<span class="fc" id="L1912">            String attribute = &quot;&quot;;</span>
<span class="fc" id="L1913">            String token = nextToken();</span>
<span class="fc bfc" id="L1914" title="All 2 branches covered.">            while (!token.isEmpty()) {</span>
<span class="fc bfc" id="L1915" title="All 4 branches covered.">                if (token.equals(&quot;=&quot;) &amp;&amp; !attribute.isEmpty()) {</span>
<span class="fc" id="L1916">                    getAttributes().put(attribute.toLowerCase(Locale.ENGLISH), nextToken());</span>
<span class="fc" id="L1917">                    attribute = &quot;&quot;;</span>
                } else {
<span class="fc bfc" id="L1919" title="All 2 branches covered.">                    if (!attribute.isEmpty()) {</span>
<span class="fc" id="L1920">                        getAttributes().put(attribute.toLowerCase(Locale.ENGLISH), &quot;&quot;);</span>
                    }
<span class="fc" id="L1922">                    attribute = token;</span>
                }
<span class="fc" id="L1924">                token = nextToken();</span>
            }
<span class="fc" id="L1926">        }</span>

        /**
         * Gets the name.
         *
         * @return the name
         */
        public String getName() {
<span class="fc" id="L1934">            return _name;</span>
        }

        /**
         * Gets the attribute.
         *
         * @param attributeName
         *            the attribute name
         *
         * @return the attribute
         */
        public String getAttribute(String attributeName) {
<span class="fc" id="L1946">            return (String) getAttributes().get(attributeName);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1951">            return &quot;ByteTag[ name=&quot; + _name + &quot;;attributes = &quot; + _attributes + ']';</span>
        }

        /**
         * Gets the attributes.
         *
         * @return the attributes
         */
        private Hashtable getAttributes() {
<span class="fc bfc" id="L1960" title="All 2 branches covered.">            if (_attributes == null) {</span>
<span class="fc" id="L1961">                _attributes = new Hashtable&lt;&gt;();</span>
            }
<span class="fc" id="L1963">            return _attributes;</span>
        }

        /** The name. */
<span class="fc" id="L1967">        private String _name = &quot;&quot;;</span>

        /** The attributes. */
        private Hashtable _attributes;

        /** The buffer. */
        private char[] _buffer;

        /** The end. */
<span class="fc" id="L1976">        private int _end = -1;</span>

        /**
         * Next token.
         *
         * @return the string
         */
        private String nextToken() {
<span class="fc" id="L1984">            int start = _end + 1;</span>
<span class="fc bfc" id="L1985" title="All 4 branches covered.">            while (start &lt; _buffer.length &amp;&amp; Character.isWhitespace(_buffer[start])) {</span>
<span class="fc" id="L1986">                start++;</span>
            }
<span class="fc bfc" id="L1988" title="All 2 branches covered.">            if (start &gt;= _buffer.length) {</span>
<span class="fc" id="L1989">                return &quot;&quot;;</span>
            }
<span class="fc bfc" id="L1991" title="All 2 branches covered.">            if (_buffer[start] == '&quot;') {</span>
<span class="fc bfc" id="L1992" title="All 4 branches covered.">                for (_end = start + 1; _end &lt; _buffer.length &amp;&amp; _buffer[_end] != '&quot;'; _end++) {</span>

                }
<span class="fc" id="L1995">                return new String(_buffer, start + 1, _end - start - 1);</span>
            }
<span class="fc bfc" id="L1997" title="All 2 branches covered.">            if (_buffer[start] == '\'') {</span>
<span class="fc bfc" id="L1998" title="All 4 branches covered.">                for (_end = start + 1; _end &lt; _buffer.length &amp;&amp; _buffer[_end] != '\''; _end++) {</span>

                }
<span class="fc" id="L2001">                return new String(_buffer, start + 1, _end - start - 1);</span>
            }
<span class="fc bfc" id="L2003" title="All 2 branches covered.">            if (_buffer[start] == '=') {</span>
<span class="fc" id="L2004">                _end = start;</span>
<span class="fc" id="L2005">                return &quot;=&quot;;</span>
            }
<span class="fc" id="L2007">            for (_end = start + 1; _end &lt; _buffer.length &amp;&amp; _buffer[_end] != '='</span>
<span class="fc bfc" id="L2008" title="All 6 branches covered.">                    &amp;&amp; !Character.isWhitespace(_buffer[_end]); _end++) {</span>

            }
<span class="fc" id="L2011">            return new String(_buffer, start, _end-- - start);</span>
        }
    }

    // =======================================================================================

    /**
     * The Class ByteTagParser.
     */
    static class ByteTagParser {

        /**
         * Instantiates a new byte tag parser.
         *
         * @param buffer
         *            the buffer
         */
<span class="fc" id="L2028">        ByteTagParser(byte[] buffer) {</span>
<span class="fc" id="L2029">            _buffer = buffer;</span>
<span class="fc" id="L2030">        }</span>

        /**
         * Gets the next tag.
         *
         * @return the next tag
         */
        ByteTag getNextTag() {
<span class="fc" id="L2038">            ByteTag byteTag = null;</span>
            do {
<span class="fc" id="L2040">                int _start = _end + 1;</span>
<span class="fc bfc" id="L2041" title="All 4 branches covered.">                while (_start &lt; _buffer.length &amp;&amp; _buffer[_start] != '&lt;') {</span>
<span class="fc" id="L2042">                    _start++;</span>
                }
                // proposed patch for bug report
                // [ 1376739 ] iframe tag not recognized if Javascript code contains '&lt;'
                // by Nathan Jakubiak
                // uncommented since it doesn't seem to fix the test in WebFrameTest.java
                // if (_scriptDepth &gt; 0 &amp;&amp; _start+1 &lt; _buffer.length &amp;&amp;
                // _buffer[ _start+1 ] != '/') {
                // _end = _start+1;
                // continue;
                // }
<span class="fc bfc" id="L2053" title="All 4 branches covered.">                for (_end = _start + 1; _end &lt; _buffer.length &amp;&amp; _buffer[_end] != '&gt;'; _end++) {</span>

                }
<span class="pc bpc" id="L2056" title="1 of 4 branches missed.">                if (_end &gt;= _buffer.length || _end &lt; _start) {</span>
<span class="fc" id="L2057">                    return null;</span>
                }
<span class="fc" id="L2059">                byteTag = new ByteTag(_buffer, _start + 1, _end - _start - 1);</span>
<span class="fc bfc" id="L2060" title="All 2 branches covered.">                if (byteTag.getName().equalsIgnoreCase(&quot;script&quot;)) {</span>
<span class="fc" id="L2061">                    _scriptDepth++;</span>
<span class="fc" id="L2062">                    return byteTag;</span>
                }
<span class="fc bfc" id="L2064" title="All 2 branches covered.">                if (byteTag.getName().equalsIgnoreCase(&quot;/script&quot;)) {</span>
<span class="fc" id="L2065">                    _scriptDepth--;</span>
                }
<span class="fc bfc" id="L2067" title="All 2 branches covered.">            } while (_scriptDepth &gt; 0);</span>
<span class="fc" id="L2068">            return byteTag;</span>
        }

        /** The script depth. */
<span class="fc" id="L2072">        private int _scriptDepth = 0;</span>

        /** The end. */
<span class="fc" id="L2075">        private int _end = -1;</span>

        /** The buffer. */
        private byte[] _buffer;
    }

    /**
     * allow access to the valid content Types.
     *
     * @return the validContentTypes
     */
    public static String[] getValidContentTypes() {
<span class="nc" id="L2087">        return validContentTypes;</span>
    }

    /**
     * allow modification of the valid content Types use with care.
     *
     * @param validContentTypes
     *            the validContentTypes to set
     */
    protected static void setValidContentTypes(String[] validContentTypes) {
<span class="nc" id="L2097">        WebResponse.validContentTypes = validContentTypes;</span>
<span class="nc" id="L2098">    }</span>

}

// =======================================================================================

class DefaultWebResponse extends WebResponse {

    DefaultWebResponse(String text) {
<span class="fc" id="L2107">        this(null, null, text);</span>
<span class="fc" id="L2108">    }</span>

    DefaultWebResponse(WebClient client, URL url, String text) {
<span class="fc" id="L2111">        this(client, FrameSelector.TOP_FRAME, url, text);</span>
<span class="fc" id="L2112">    }</span>

    DefaultWebResponse(WebClient client, FrameSelector frame, URL url, String text) {
<span class="fc" id="L2115">        super(client, frame, url, text);</span>
<span class="fc" id="L2116">    }</span>

    /**
     * Returns the response code associated with this response.
     **/
    @Override
    public int getResponseCode() {
<span class="fc" id="L2123">        return HttpURLConnection.HTTP_OK;</span>
    }

    /**
     * Returns the response message associated with this response.
     **/
    @Override
    public String getResponseMessage() {
<span class="nc" id="L2131">        return &quot;OK&quot;;</span>
    }

    @Override
    public String[] getHeaderFieldNames() {
<span class="nc" id="L2136">        return new String[] { &quot;Content-type&quot; };</span>
    }

    /**
     * Returns the value for the specified header field. If no such field is defined, will return null.
     **/
    @Override
    public String getHeaderField(String fieldName) {
<span class="fc bfc" id="L2144" title="All 2 branches covered.">        if (fieldName.equalsIgnoreCase(&quot;Content-type&quot;)) {</span>
<span class="fc" id="L2145">            return &quot;text/html; charset=us-ascii&quot;;</span>
        }
<span class="fc" id="L2147">        return null;</span>
    }

    @Override
    public String[] getHeaderFields(String fieldName) {
<span class="fc" id="L2152">        String value = getHeaderField(fieldName);</span>
<span class="pc bpc" id="L2153" title="1 of 2 branches missed.">        return value == null ? new String[0] : new String[] { value };</span>
    }

    @Override
    public String toString() {
        try {
<span class="nc" id="L2159">            return &quot;DefaultWebResponse [&quot; + getText() + &quot;]&quot;;</span>
<span class="nc" id="L2160">        } catch (IOException e) { // should never happen</span>
<span class="nc" id="L2161">            return &quot;DefaultWebResponse [???]&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>